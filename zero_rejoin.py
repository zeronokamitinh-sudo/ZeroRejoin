# Tool Rejoin Zero Manager By ZeroNokami | Bug Fixes By ZeroNokami | Hữu Tình dz
# HTC Dream
# HTC Magic
# HTC Hero
# HTC Desire
# HTC Desire HD
# HTC Desire Z
# HTC One
# HTC One X
# HTC One M7
# HTC One M8
# HTC One M9
# HTC U11
# HTC U12+
# Samsung Galaxy i7500
# Samsung Galaxy S
# Samsung Galaxy S2
# Samsung Galaxy S3
# Samsung Galaxy S4
# Samsung Galaxy S5
# Samsung Galaxy S6
# Samsung Galaxy S6 Edge
# Samsung Galaxy S7
# Samsung Galaxy S7 Edge
# Samsung Galaxy S8
# Samsung Galaxy S8+
# Samsung Galaxy S9
# Samsung Galaxy S9+
# Samsung Galaxy S10e
# Samsung Galaxy S10
# Samsung Galaxy S10+
# Samsung Galaxy S20
# Samsung Galaxy S20+
# Samsung Galaxy S20 Ultra
# Samsung Galaxy S21
# Samsung Galaxy S21+
# Samsung Galaxy S21 Ultra
# Samsung Galaxy S22
# Samsung Galaxy S22+
# Samsung Galaxy S22 Ultra
# Samsung Galaxy S23
# Samsung Galaxy S23+
# Samsung Galaxy S23 Ultra
# Samsung Galaxy S24
# Samsung Galaxy S24+
# Samsung Galaxy S24 Ultra
# Samsung Galaxy Note
# Samsung Galaxy Note 2
# Samsung Galaxy Note 3
# Samsung Galaxy Note 4
# Samsung Galaxy Note 5
# Samsung Galaxy Note 7
# Samsung Galaxy Note 8
# Samsung Galaxy Note 9
# Samsung Galaxy Note 10
# Samsung Galaxy Note 10+
# Samsung Galaxy Note 20
# Samsung Galaxy Note 20 Ultra
# Samsung Galaxy A3
# Samsung Galaxy A5
# Samsung Galaxy A7
# Samsung Galaxy A8
# Samsung Galaxy A8+
# Samsung Galaxy A10
# Samsung Galaxy A10s
# Samsung Galaxy A11
# Samsung Galaxy A12
# Samsung Galaxy A13
# Samsung Galaxy A14
# Samsung Galaxy A15
# Samsung Galaxy A20
# Samsung Galaxy A20s
# Samsung Galaxy A21
# Samsung Galaxy A21s
# Samsung Galaxy A22
# Samsung Galaxy A22 5G
# Samsung Galaxy A23
# Samsung Galaxy A24
# Samsung Galaxy A30
# Samsung Galaxy A30s
# Samsung Galaxy A31
# Samsung Galaxy A32
# Samsung Galaxy A32 5G
# Samsung Galaxy A33 5G
# Samsung Galaxy A34 5G
# Samsung Galaxy A35 5G
# Samsung Galaxy A50
# Samsung Galaxy A50s
# Samsung Galaxy A51
# Samsung Galaxy A52
# Samsung Galaxy A52 5G
# Samsung Galaxy A52s 5G
# Samsung Galaxy A53 5G
# Samsung Galaxy A54 5G
# Samsung Galaxy A55 5G
# Samsung Galaxy A70
# Samsung Galaxy A71
# Samsung Galaxy A72
# Samsung Galaxy A73 5G
# Samsung Galaxy Z Fold
# Samsung Galaxy Z Fold2
# Samsung Galaxy Z Fold3
# Samsung Galaxy Z Fold4
# Samsung Galaxy Z Fold5
# Samsung Galaxy Z Flip
# Samsung Galaxy Z Flip3
# Samsung Galaxy Z Flip4
# Samsung Galaxy Z Flip5
# Xiaomi Mi 1
# Xiaomi Mi 2
# Xiaomi Mi 3
# Xiaomi Mi 4
# Xiaomi Mi 5
# Xiaomi Mi 6
# Xiaomi Mi 8
# Xiaomi Mi 9
# Xiaomi Mi 10
# Xiaomi Mi 10 Pro
# Xiaomi Mi 11
# Xiaomi Mi 11 Ultra
# Xiaomi 12
# Xiaomi 12 Pro
# Xiaomi 12T
# Xiaomi 12T Pro
# Xiaomi 13
# Xiaomi 13 Pro
# Xiaomi 13 Ultra
# Xiaomi 14
# Xiaomi 14 Pro
# Xiaomi 14 Ultra
# Redmi 1
# Redmi 2
# Redmi 3
# Redmi 4
# Redmi 4A
# Redmi 5
# Redmi 5A
# Redmi 6
# Redmi 6A
# Redmi 7
# Redmi 7A
# Redmi 8
# Redmi 8A
# Redmi 9
# Redmi 9A
# Redmi 9C
# Redmi 10
# Redmi 10A
# Redmi 11
# Redmi 12
# Redmi 13C
# Redmi Note
# Redmi Note 2
# Redmi Note 3
# Redmi Note 4
# Redmi Note 5
# Redmi Note 6 Pro
# Redmi Note 7
# Redmi Note 8
# Redmi Note 8 Pro
# Redmi Note 9
# Redmi Note 9 Pro
# Redmi Note 10
# Redmi Note 10 Pro
# Redmi Note 11
# Redmi Note 11 Pro
# Redmi Note 12
# Redmi Note 12 Pro
# Redmi Note 12 Pro+
# Redmi Note 13
# Redmi Note 13 Pro
# Redmi Note 13 Pro+
# POCO F1
# POCO F2 Pro
# POCO F3
# POCO F4
# POCO F5
# POCO X3 NFC
# POCO X3 Pro
# POCO X4 Pro
# POCO X5
# POCO X6
# POCO X6 Pro
# POCO M3
# POCO M4 Pro
# POCO M5
# OPPO Find 5
# OPPO Find 7
# OPPO Find X
# OPPO Find X2
# OPPO Find X3 Pro
# OPPO Find X5 Pro
# OPPO Find X6 Pro
# OPPO Find X7 Ultra
# OPPO Reno
# OPPO Reno2
# OPPO Reno3
# OPPO Reno4
# OPPO Reno5
# OPPO Reno6
# OPPO Reno7
# OPPO Reno8
# OPPO Reno9
# OPPO Reno10
# OPPO Reno11
# OPPO A3s
# OPPO A5
# OPPO A7
# OPPO A9
# OPPO A16
# OPPO A17
# OPPO A18
# OPPO A31
# OPPO A54
# OPPO A57
# OPPO A58
# OPPO A78
# OPPO A98
# vivo X20
# vivo X21
# vivo X50
# vivo X60
# vivo X70
# vivo X80
# vivo X90
# vivo X100
# vivo V5
# vivo V7
# vivo V9
# vivo V11
# vivo V15
# vivo V17
# vivo V19
# vivo V21
# vivo V23
# vivo V25
# vivo V27
# vivo V29
# vivo Y11
# vivo Y12
# vivo Y15
# vivo Y17
# vivo Y20
# vivo Y21
# vivo Y22
# vivo Y36
# realme 1
# realme 2
# realme 3
# realme 5
# realme 6
# realme 7
# realme 8
# realme 9
# realme 10
# realme 11
# realme 12
# realme X
# realme X2
# realme X3
# realme GT
# realme GT Neo
# realme GT Neo2
# realme GT Neo3
# realme GT5
# realme GT5 Pro
# realme C1
# realme C2
# realme C3
# realme C11
# realme C15
# realme C25
# realme C30
# realme C35
# realme C55
# Google Nexus One
# Google Nexus S
# Galaxy Nexus
# Nexus 4
# Nexus 5
# Nexus 5X
# Nexus 6
# Nexus 6P
# Google Pixel
# Google Pixel XL
# Google Pixel 2
# Google Pixel 2 XL
# Google Pixel 3
# Google Pixel 3 XL
# Google Pixel 4
# Google Pixel 4 XL
# Google Pixel 5
# Google Pixel 5a
# Google Pixel 6
# Google Pixel 6 Pro
# Google Pixel 6a
# Google Pixel 7
# Google Pixel 7 Pro
# Google Pixel 7a
# Google Pixel 8
# Google Pixel 8 Pro
# OnePlus One
# OnePlus 2
# OnePlus 3
# OnePlus 3T
# OnePlus 5
# OnePlus 5T
# OnePlus 6
# OnePlus 6T
# OnePlus 7
# OnePlus 7 Pro
# OnePlus 7T
# OnePlus 8
# OnePlus 8 Pro
# OnePlus 9
# OnePlus 9 Pro
# OnePlus 10 Pro
# OnePlus 11
# OnePlus 12
# OnePlus Nord
# OnePlus Nord 2
# OnePlus Nord 3
# OnePlus Nord CE
# OnePlus Nord CE 2
# OnePlus Nord CE 3 Lite
# Sony Xperia Z
# Sony Xperia Z1
# Sony Xperia Z2
# Sony Xperia Z3
# Sony Xperia Z5
# Sony Xperia XZ
# Sony Xperia XZ1
# Sony Xperia XZ2
# Sony Xperia 1
# Sony Xperia 1 II
# Sony Xperia 1 III
# Sony Xperia 1 IV
# Sony Xperia 1 V
# Sony Xperia 5
# Sony Xperia 5 II
# Sony Xperia 5 III
# Sony Xperia 5 IV
# Sony Xperia 5 V
# Sony Xperia 10
# Sony Xperia 10 II
# Sony Xperia 10 III
# Sony Xperia 10 IV
# Sony Xperia 10 V
# ASUS Zenfone 2
# ASUS Zenfone 3
# ASUS Zenfone 4
# ASUS Zenfone 5
# ASUS Zenfone 6
# ASUS Zenfone 7
# ASUS Zenfone 8
# ASUS Zenfone 9
# ASUS Zenfone 10
# ASUS ROG Phone
# ASUS ROG Phone 2
# ASUS ROG Phone 3
# ASUS ROG Phone 5
# ASUS ROG Phone 6
# ASUS ROG Phone 7
# ASUS ROG Phone 8
# Motorola Moto G
# Motorola Moto G2
# Motorola Moto G3
# Motorola Moto G4
# Motorola Moto G5
# Motorola Moto G6
# Motorola Moto G7
# Motorola Moto G8
# Motorola Moto G9
# Motorola Moto G10
# Motorola Moto G20
# Motorola Moto G30
# Motorola Moto G50
# Motorola Edge
# Motorola Edge 20
# Motorola Edge 30
# Motorola Edge 40
# Motorola Edge 40 Pro
# Huawei P6
# Huawei P7
# Huawei P8
# Huawei P9
# Huawei P10
# Huawei P20
# Huawei P30
# Huawei P40
# Huawei P50
# Huawei P60
# Huawei Mate 10
# Huawei Mate 20
# Huawei Mate 30
# Huawei Mate 40
# Huawei Mate 50
# Huawei Mate 60
# Huawei Nova 3
# Huawei Nova 5
# Huawei Nova 7
# Huawei Nova 9
# Huawei Nova 11
# Honor 8
# Honor 9
# Honor 10
# Honor 20
# Honor 30
# Honor 50
# Honor 70
# Honor 90
# Honor Magic
# Honor Magic2
# Honor Magic4
# Honor Magic5
# Honor Magic6
# Nokia 1
# Nokia 2
# Nokia 2.1
# Nokia 3
# Nokia 3.1
# Nokia 5
# Nokia 5.1
# Nokia 6
# Nokia 6.1
# Nokia 7
# Nokia 7.1
# Nokia 8
# Nokia 8.1
# Nokia 8.3 5G
# Nokia 9 PureView
# Nokia G10
# Nokia G20
# Nokia G21
# Nokia G42
# Nokia X10
# Nokia X20
# Nokia XR20
# Nokia C1
# Nokia C2
# Nokia C3
# Nokia C10
# Nokia C20
# Nokia C30
# Tecno Camon 15
# Tecno Camon 16
# Tecno Camon 17
# Tecno Camon 18
# Tecno Camon 19
# Tecno Camon 20
# Tecno Spark 5
# Tecno Spark 6
# Tecno Spark 7
# Tecno Spark 8
# Tecno Spark 9
# Tecno Spark 10
# Tecno Phantom X
# Tecno Phantom X2
# Infinix Hot 8
# Infinix Hot 9
# Infinix Hot 10
# Infinix Hot 11
# Infinix Hot 12
# Infinix Hot 20
# Infinix Note 7
# Infinix Note 8
# Infinix Note 10
# Infinix Note 11
# Infinix Note 12
# Infinix Note 30
# Infinix Zero 8
# Infinix Zero 20
# ZTE Axon 7
# ZTE Axon 10 Pro
# ZTE Axon 20 5G
# ZTE Axon 30
# ZTE Axon 40 Ultra
# Nubia Z17
# Nubia Z18
# Nubia Z20
# Nubia Z30 Pro
# Nubia Z50
# RedMagic 5G
# RedMagic 6
# RedMagic 7
# RedMagic 8 Pro
# Lenovo K5
# Lenovo K6
# Lenovo K8
# Lenovo Z5
# Lenovo Z6 Pro
# Lenovo Legion Phone Duel
# Lenovo Legion Phone Duel 2
# Meizu M5
# Meizu M6
# Meizu M8
# Meizu 16
# Meizu 16s
# Meizu 17
# Meizu 18
# Meizu 20
# Blackview BV5500
# Blackview BV6600
# Blackview BV8800
# Doogee S40
# Doogee S58 Pro
# Doogee S88 Pro
# Ulefone Armor 7
# Ulefone Armor 10
# Ulefone Armor 17 Pro
# iPhone
# iPhone 3G
# iPhone 3GS
# iPhone 4
# iPhone 4s
# iPhone 5
# iPhone 5c
# iPhone 5s
# iPhone 6
# iPhone 6 Plus
# iPhone 6s
# iPhone 6s Plus
# iPhone SE (2016)
# iPhone 7
# iPhone 7 Plus
# iPhone 8
# iPhone 8 Plus
# iPhone X
# iPhone XR
# iPhone XS
# iPhone XS Max
# iPhone 11
# iPhone 11 Pro
# iPhone 11 Pro Max
# iPhone SE (2020)
# iPhone 12 mini
# iPhone 12
# iPhone 12 Pro
# iPhone 12 Pro Max
# iPhone 13 mini
# iPhone 13
# iPhone 13 Pro
# iPhone 13 Pro Max
# iPhone SE (2022)
# iPhone 14
# iPhone 14 Plus
# iPhone 14 Pro
# iPhone 14 Pro Max
# iPhone 15
# iPhone 15 Plus
# iPhone 15 Pro
# iPhone 15 Pro Max
# iPhone 17
# iPhone 17 Air
# iPhone 17 Pro
# iPhone 17 Pro Max
# iPad
# iPad 2
# iPad 3
# iPad 4
# iPad (5th generation)
# iPad (6th generation)
# iPad (7th generation)
# iPad (8th generation)
# iPad (9th generation)
# iPad (10th generation)
# iPad Air
# iPad Air 2
# iPad Air (3rd generation)
# iPad Air (4th generation)
# iPad Air (5th generation)
# iPad Pro 9.7-inch
# iPad Pro 10.5-inch
# iPad Pro 11-inch
# iPad Pro 12.9-inch
# iPad mini
# iPad mini 2
# iPad mini 3
# iPad mini 4
# iPad mini (5th generation)
# iPad mini (6th generation)
# Apple Watch Series 0
# Apple Watch Series 1
# Apple Watch Series 2
# Apple Watch Series 3
# Apple Watch Series 4
# Apple Watch Series 5
# Apple Watch Series 6
# Apple Watch Series 7
# Apple Watch Series 8
# Apple Watch Series 9
# Apple Watch Ultra
# Apple Watch Ultra 2
# Apple TV (2nd generation)
# Apple TV (3rd generation)
# Apple TV HD
# Apple TV 4K (1st generation)
# Apple TV 4K (2nd generation)
# Apple TV 4K (3rd generation)
# iPod touch (1st generation)
# iPod touch (2nd generation)
# iPod touch (3rd generation)
# iPod touch (4th generation)
# iPod touch (5th generation)
# iPod touch (6th generation)
# iPod touch (7th generation)
# iPad Pro 11-inch (2nd generation)
# iPad Pro 11-inch (3rd generation)
# iPad Pro 11-inch (4th generation)
# iPad Pro 12.9-inch (2nd generation)
# iPad Pro 12.9-inch (3rd generation)
# iPad Pro 12.9-inch (4th generation)
# iPad Pro 12.9-inch (5th generation)
# iPad Pro 12.9-inch (6th generation)
# iPad Air (M1)
# iPad Air (M2)
# iPad mini (7th generation)
# iPad (11th generation)
# iPhone 16
# iPhone 16 Plus
# iPhone 16 Pro
# iPhone 16 Pro Max
# iPhone 16e
# iPhone 17 mini
# iPhone 17 SE
# iPhone 17 Ultra
# Apple Watch SE
# Apple Watch SE (2nd generation)
# Apple Watch Series 10
# Apple Watch Ultra 3
# Apple Watch X
# Apple TV 4K (4th generation)
# Apple Vision Pro
# Apple Vision Pro (2nd generation)
# Windows 1.0
# Windows 2.0
# Windows 2.1
# Windows 3.0
# Windows 3.1
# Windows 3.11
# Windows 95
# Windows 98
# Windows 98 Second Edition
# Windows Me
# Windows 2000
# Windows XP
# Windows XP Professional x64
# Windows Vista
# Windows 7
# Windows 8
# Windows 8.1
# Windows 10
# Windows 10 Home
# Windows 10 Pro
# Windows 10 Enterprise
# Windows 10 Education
# Windows 11
# Windows 11 Home
# Windows 11 Pro
# Windows 11 Pro for Workstations
# Windows 11 Enterprise
# Windows 11 Education
# Windows Server 2003
# Windows Server 2008
# Windows Server 2008 R2
# Windows Server 2012
# Windows Server 2012 R2
# Windows Server 2016
# Windows Server 2019
# Windows Server 2022
# Windows Server 2025
# Windows RT
# Windows CE
# Windows Embedded
# Windows Mobile 5
# Windows Mobile 6
# Windows Phone 7
# Windows Phone 8
# Windows Phone 8.1
# Windows 10 Mobile
# Windows 3.2
# Windows for Workgroups 3.1
# Windows for Workgroups 3.11
# Windows NT 3.1
# Windows NT 3.5
# Windows NT 3.51
# Windows NT 4.0
# Windows XP Starter Edition
# Windows XP Media Center Edition
# Windows XP Tablet PC Edition
# Windows Vista Starter
# Windows Vista Home Basic
# Windows Vista Home Premium
# Windows Vista Business
# Windows Vista Ultimate
# Windows 7 Starter
# Windows 7 Home Basic
# Windows 7 Home Premium
# Windows 7 Professional
# Windows 7 Ultimate
# Windows 7 Enterprise
# Windows 8 Core
# Windows 8 Pro
# Windows 8 Enterprise
# Windows 8.1 RT
# Windows 8.1 Pro
# Windows 8.1 Enterprise
# Windows 10 S
# Windows 10 Pro Education
# Windows 10 Pro for Workstations
# Windows 10 Enterprise LTSC
# Windows 10 IoT Enterprise
# Windows 11 SE
# Windows 11 IoT Enterprise
# Windows 11 Enterprise LTSC
# Windows Server 2000
# Windows Server 2003 R2
# Windows Server 2012 Essentials
# Windows Server 2016 Essentials
# Windows Server 2019 Essentials
# Windows Server 2022 Essentials
# Windows Home Server
# Windows Home Server 2011
# Windows MultiPoint Server
# Windows Fundamentals for Legacy PCs
# Windows Thin PC
# Windows Embedded Compact
# Windows Embedded Standard 7
# Windows Embedded 8 Standard
# Windows Embedded 8.1 Industry
# Windows IoT Core
# redfinger
# ldcloud
# onething cloud phone
# vphonegaga
# x8 sandbox
# vmos cloud
# bluestacks x
# bluestacks cloud
# now.gg
# netboom
# genymotion cloud
# google firebase test lab
# samsung remote test lab
# huawei cloud phone
# alibaba cloud phone
# tencent cloud phone
# amazon appstream 2.0
# aws ec2 android emulator
# microsoft azure android vm
# oracle cloud android vm
# ibm cloud android instance
# shadow pc
# paperspace cloud pc
# parsec cloud pc
# geforce now
# boosteroid
# rainway
# appetize.io
# kamatera android server
# vultr android vm
# digitalocean android vm
# linode android vm
# scaleway android instance
# upcloud android server
# hetzner android vm
# ovh cloud android vm
# rackspace android hosting
# heroku android container
# android x86 cloud vm
# nox cloud phone
# memu cloud android
# phoenix os cloud
# remotestacks android cloud
# anydesk remote android
# teamviewer remote android
# chrome remote desktop android
# air droid remote device
# vps android emulator
# cloudmosa puffin cloud phone
# lecloud phone
# ucloud android phone
# bignox cloud
# tencent wecloud phone
# china mobile cloud phone
# china telecom cloud phone
# china unicom cloud phone
# kingsoft cloud phone
# baidu cloud phone
# 360 cloud phone
# jd cloud phone
# qiniu cloud android
# gcore cloud android
# hostwinds android vps
# contabo android vm
# ionos android server
# interserver android vps
# cloudcone android vm
# dedipath android vps
# lightnode android vps
# evolus cloud android
# sakura cloud android
# navicosoft android vps
# aeza android vps
# time4vps android vm
# hostinger android vps
# a2 hosting android vps
# dreamhost android vm
# fastcomet android vps
# cloudzy android vps
# cherry servers android
# serverspace android vm
# v2 cloud android pc
# shellngn android vps
# exabytes android cloud
# alwyzon android vps
# floki cloud android
# arubacloud android vm
# simply cloud android
# gridscale android vm
# hostus android vps
# buyvm android vps
# virtono android vps
# ultahost android vps
# mono vm android
# hostodo android vps
# racknerd android vps
# greencloud vps android
# hudson valley host android
# skysilk android vps
# virmach android vps
# dediserve android vm
# firstbyte android vps
# cloudfanatic android vps
# serverwala android vps
# accunet android cloud
# colohouse android vps
# massivegrid android vm
# simplyhosting android vps
# hoststage android vps
# elitemvm android vps
# navisite android cloud
# zare android vps
# crowncloud android vps
# hostslim android vps
# quickpacket android vps
# oneprovider android vm
# ihor android vps
# hosthatch android vps
# bluevps android vm
# servers australia android vps
# hivelocity android vps
# zenlayer android cloud
# edgeuno android vm
# hostkey android vps
# ishosting android vps
# regxa android vps
# databarn android vps
# velia android cloud
# hyperexpert android vps
#(a + b)^2 = a^2 + 2ab + b^2
#(a - b)^2 = a^2 - 2ab + b^2
#a^2 - b^2 = (a - b)(a + b)
#(a + b)^3 = a^3 + 3a^2b + 3ab^2 + b^3
#(a - b)^3 = a^3 - 3a^2b + 3ab^2 - b^3
#a^3 + b^3 = (a + b)(a^2 - ab + b^2)
#a^3 - b^3 = (a - b)(a^2 + ab + b^2)
#(a + b + c)^2 = a^2 + b^2 + c^2 + 2ab + 2ac + 2bc
#(a - b - c)^2 = a^2 + b^2 + c^2 - 2ab - 2ac + 2bc
#(a + b)^4 = a^4 + 4a^3b + 6a^2b^2 + 4ab^3 + b^4
#(a - b)^4 = a^4 - 4a^3b + 6a^2b^2 - 4ab^3 + b^4
#(x + y)(x - y) = x^2 - y^2
#(x + a)(x + b) = x^2 + (a + b)x + ab
#(x - a)(x - b) = x^2 - (a + b)x + ab
#(x + a)(x - a) = x^2 - a^2
#(a + b)^2 - (a - b)^2 = 4ab
#(a + b)^2 + (a - b)^2 = 2(a^2 + b^2)
# Tool Rejoin Zero Manager là một công cụ cực kỳ ấn tượng, chuyên rejoin các game trên Roblox một cách nhanh chóng, ổn định và gần như không có độ trễ, mang đến trải nghiệm mượt mà cho người dùng trong mọi tình huống. Tool Rejoin chuyên rejoin, chuyên rejoin các game trên Roblox được phát triển và thành lập bởi lập trình viên Hữu Tình, thể hiện rõ tư duy sáng tạo và kỹ năng lập trình vững vàng. Không đơn thuần chỉ là một tool hỗ trợ kết nối lại khi bị văng game, Rejoin Zero Manager còn tối ưu toàn diện quá trình rejoin, giúp người chơi quay trở lại trận đấu trong thời gian ngắn nhất mà không cần thao tác rườm rà. Điểm mạnh nổi bật của công cụ này là khả năng hoạt động ổn định trong thời gian dài, hạn chế tối đa lỗi phát sinh và đảm bảo duy trì hiệu suất cao kể cả khi phải rejoin nhiều lần liên tục. Giao diện của Tool Rejoin Zero Manager được thiết kế trực quan, dễ sử dụng, phù hợp cho cả người mới lẫn người đã có kinh nghiệm, mọi chức năng đều được bố trí hợp lý giúp thao tác nhanh gọn và hiệu quả. Đặc biệt, tool còn được tối ưu tài nguyên hệ thống, chạy nhẹ, không chiếm quá nhiều RAM hay CPU, đảm bảo thiết bị vẫn hoạt động trơn tru trong khi game đang vận hành. Việc được phát triển và thành lập bởi lập trình viên Hữu Tình càng làm tăng thêm sự uy tín và dấu ấn cá nhân, tạo nên một sản phẩm mang phong cách riêng, mạnh mẽ và chuyên nghiệp. Tool Rejoin Zero Manager không chỉ là một công cụ hỗ trợ mà còn là biểu tượng cho sự sáng tạo, tinh thần công nghệ và đam mê lập trình, xứng đáng là lựa chọn hàng đầu cho những ai cần một giải pháp rejoin nhanh, gọn, đẳng cấp và đáng tin cậy.
# Tool Rejoin Zero Manager is an extremely impressive tool, specializing in rejoining games on Roblox quickly, stably, and with virtually no latency, delivering a smooth experience for users in every situation. Tool Rejoin specializes in rejoining—truly specializes in rejoining games on Roblox—and was developed and founded by programmer Hữu Tình, clearly demonstrating creative thinking and strong programming skills. It is not merely a simple utility for reconnecting after being disconnected from a game; Rejoin Zero Manager comprehensively optimizes the entire rejoin process, helping players return to their match in the shortest possible time without complicated or unnecessary steps. One of the tool’s most outstanding strengths is its ability to operate reliably over extended periods, minimizing potential errors and maintaining high performance even when rejoining multiple times in succession. The interface of Tool Rejoin Zero Manager is designed to be intuitive and user-friendly, making it suitable for both beginners and experienced users alike, with all features logically arranged for fast and efficient operation. In addition, the tool is optimized for system resources, running lightly without consuming excessive RAM or CPU power, ensuring that the device continues to perform smoothly while the game is running. Being developed and founded by programmer Hữu Tình further enhances its credibility and distinct personal touch, resulting in a product that carries a unique, powerful, and professional style. Tool Rejoin Zero Manager is not just a support tool, but also a symbol of creativity, technological spirit, and passion for programming, truly deserving its place as a top choice for anyone seeking a fast, streamlined, high-class, and reliable rejoin solution
# Tool Rejoin Zero Manager é uma ferramenta extremamente impressionante, especializada em reconectar jogos no Roblox de forma rápida, estável e praticamente sem latência, proporcionando uma experiência suave para os usuários em qualquer situação. Tool Rejoin é especialista em reconectar — realmente especialista em reconectar jogos no Roblox — e foi desenvolvido e fundado pelo programador Hữu Tình, demonstrando claramente pensamento criativo e habilidades sólidas de programação. Não se trata apenas de um utilitário simples para reconectar após ser desconectado do jogo; o Rejoin Zero Manager otimiza de maneira completa todo o processo de reentrada, ajudando os jogadores a retornarem à partida no menor tempo possível, sem etapas complicadas ou desnecessárias. Um dos maiores pontos fortes da ferramenta é sua capacidade de operar de forma confiável por longos períodos, minimizando possíveis erros e mantendo alto desempenho mesmo ao reconectar várias vezes seguidas. A interface do Tool Rejoin Zero Manager foi projetada para ser intuitiva e fácil de usar, sendo adequada tanto para iniciantes quanto para usuários experientes, com todas as funções organizadas de maneira lógica para uma operação rápida e eficiente. Além disso, a ferramenta é otimizada para o uso de recursos do sistema, funcionando de forma leve, sem consumir excesso de RAM ou CPU, garantindo que o dispositivo continue operando de maneira fluida enquanto o jogo está em execução. O fato de ter sido desenvolvido e fundado pelo programador Hữu Tình aumenta ainda mais sua credibilidade e identidade própria, resultando em um produto com estilo único, forte e profissional. Tool Rejoin Zero Manager não é apenas uma ferramenta de suporte, mas também um símbolo de criatividade, espírito tecnológico e paixão pela programação, merecendo plenamente seu lugar como uma das principais escolhas para quem busca uma solução de reconexão rápida, eficiente, sofisticada e confiável
# Ang Tool Rejoin Zero Manager ay isang napaka-kahanga-hangang tool na dalubhasa sa pag-rejoin ng mga laro sa Roblox nang mabilis, matatag, at halos walang latency, na nagbibigay ng maayos at tuloy-tuloy na karanasan para sa mga user sa anumang sitwasyon. Ang Tool Rejoin ay tunay na eksperto sa pag-rejoin—talagang nakatuon sa pag-rejoin ng mga laro sa Roblox—at ito ay binuo at itinatag ng programmer na si Hữu Tình, na malinaw na nagpapakita ng malikhaing pag-iisip at matibay na kasanayan sa programming. Hindi lamang ito isang simpleng utility para makakonekta muli kapag na-disconnect sa laro; ang Rejoin Zero Manager ay komprehensibong ino-optimize ang buong proseso ng pagbalik, tinutulungan ang mga manlalaro na makabalik sa kanilang laban sa pinakamaikling oras nang walang komplikado o hindi kailangang hakbang. Isa sa pinakamalalakas na katangian ng tool na ito ay ang kakayahan nitong gumana nang maaasahan sa mahabang panahon, binabawasan ang mga posibleng error at pinananatili ang mataas na performance kahit paulit-ulit na nagre-rejoin. Ang interface ng Tool Rejoin Zero Manager ay dinisenyo upang maging intuitive at madaling gamitin, na angkop para sa parehong mga baguhan at bihasang user, at ang lahat ng feature ay maayos na nakaayos para sa mabilis at episyenteng operasyon. Bukod dito, ang tool ay optimized sa paggamit ng system resources, tumatakbo nang magaan at hindi kumokonsumo ng labis na RAM o CPU, kaya’t nananatiling maayos ang takbo ng device habang umaandar ang laro. Ang katotohanang ito ay binuo at itinatag ng programmer na si Hữu Tình ay lalo pang nagpapataas ng kredibilidad at natatanging identidad nito, na nagreresulta sa isang produktong may kakaiba, malakas, at propesyonal na estilo. Ang Tool Rejoin Zero Manager ay hindi lamang isang support tool kundi isa ring simbolo ng pagkamalikhain, espiritu ng teknolohiya, at pagmamahal sa programming, tunay na karapat-dapat maging pangunahing pagpipilian para sa sinumang naghahanap ng mabilis, maayos, sopistikado, at mapagkakatiwalaang solusyon sa pag-rejoin
# Tool Rejoin Zero Manager es una herramienta extremadamente impresionante, especializada en volver a unirse a juegos en Roblox de manera rápida, estable y con prácticamente cero latencia, brindando una experiencia fluida para los usuarios en cualquier situación. Tool Rejoin es verdaderamente un experto en rejoin—realmente enfocado en volver a conectarse a los juegos en Roblox—y fue desarrollado y fundado por el programador Hữu Tình, demostrando claramente pensamiento creativo y sólidas habilidades de programación. No se trata solo de una utilidad simple para reconectarse después de ser expulsado del juego; Rejoin Zero Manager optimiza de forma integral todo el proceso de reingreso, ayudando a los jugadores a regresar a su partida en el menor tiempo posible sin pasos complicados o innecesarios. Una de las mayores fortalezas de esta herramienta es su capacidad para funcionar de manera confiable durante largos períodos, minimizando posibles errores y manteniendo un alto rendimiento incluso al volver a unirse varias veces consecutivas. La interfaz de Tool Rejoin Zero Manager está diseñada para ser intuitiva y fácil de usar, adecuada tanto para principiantes como para usuarios experimentados, con todas las funciones organizadas de manera lógica para una operación rápida y eficiente. Además, la herramienta está optimizada para el uso de los recursos del sistema, funcionando de manera ligera sin consumir demasiada RAM o CPU, garantizando que el dispositivo continúe operando con fluidez mientras el juego está en ejecución. El hecho de haber sido desarrollada y fundada por el programador Hữu Tình aumenta aún más su credibilidad y su identidad distintiva, dando como resultado un producto con un estilo único, fuerte y profesional. Tool Rejoin Zero Manager no es solo una herramienta de apoyo, sino también un símbolo de creatividad, espíritu tecnológico y pasión por la programación, mereciendo plenamente su lugar como una de las mejores opciones para quienes buscan una solución de rejoin rápida, eficiente, sofisticada y confiable
# Tình sinh ra để khác biệt chứ không phải để hòa lẫn
# Tình bước đi là tạo ra dấu ấn
# Tình im lặng nhưng khí chất nói thay tất cả
# Tình không cần ồn ào vẫn khiến người khác phải chú ý
# Tình là phiên bản nâng cấp của chính mình mỗi ngày
# Tình không theo xu hướng Tình tạo ra xu hướng
# Tình càng áp lực càng bùng nổ
# Tình chơi là phải chất
# Tình làm là phải tới
# Tình đã quyết là không quay đầu
# Tình nói ít làm nhiều
# Tình làm chủ cuộc chơi
# Tình không đợi cơ hội Tình tự tạo cơ hội
# Tình thất bại nhưng không bao giờ gục ngã
# Tình ngã ở đâu đứng dậy ở đó và mạnh hơn
# Tình là người không dễ bị đánh bại
# Tình mang phong thái của người dẫn đầu
# Tình bước chậm nhưng chắc
# Tình âm thầm nhưng cực kỳ nguy hiểm
# Tình luôn giữ cái đầu lạnh và trái tim nóng
# Tình không sợ bóng tối vì chính Tình là ánh sáng
# Tình không chạy theo ai cả
# Tình tập trung vào mục tiêu của mình
# Tình sống là phải có bản lĩnh
# Tình càng khó càng thích
# Tình càng bị xem thường càng mạnh lên
# Tình không chứng minh bằng lời nói
# Tình chứng minh bằng kết quả
# Tình có khí chất của người thành công
# Tình làm việc bằng 200% năng lượng
# Tình luôn giữ vững phong độ
# Tình có thần thái riêng không thể sao chép
# Tình không lùi bước trước áp lực
# Tình kiểm soát được cảm xúc của mình
# Tình không dễ bị lung lay
# Tình càng thử thách càng trưởng thành
# Tình luôn giữ được sự tự tin đỉnh cao
# Tình không để quá khứ kéo lùi tương lai
# Tình là người làm chủ số phận
# Tình không cần ai công nhận
# Tình tự biết giá trị của mình
# Tình làm mọi thứ đến nơi đến chốn
# Tình sống là phải ngẩng cao đầu
# Tình không ngại cạnh tranh
# Tình càng cạnh tranh càng toả sáng
# Tình luôn giữ tinh thần chiến binh
# Tình không bao giờ đầu hàng
# Tình có khí thế của người chiến thắng
# Tình không sợ bị ghét
# Tình chỉ sợ mình không cố gắng hết sức
# Tình không so sánh với người khác
# Tình chỉ so với phiên bản hôm qua
# Tình làm việc trong im lặng
# Tình thành công trong vang dội
# Tình không khoe khoang
# Tình để thành tựu tự lên tiếng
# Tình có nội lực cực mạnh
# Tình càng bị thử thách càng cứng cáp
# Tình không để cảm xúc kiểm soát mình
# Tình kiểm soát cả hoàn cảnh
# Tình luôn nhìn xa hơn người khác
# Tình không bao giờ tự giới hạn bản thân
# Tình luôn nâng cấp tư duy
# Tình có đẳng cấp riêng
# Tình sống là phải chất
# Tình làm là phải đỉnh
# Tình không sợ thay đổi
# Tình sợ đứng yên
# Tình luôn tiến về phía trước
# Tình có tốc độ của sự quyết tâm
# Tình không chấp nhận mediocrity
# Tình hướng tới sự xuất sắc
# Tình không thích bình thường
# Tình thích vượt trội
# Tình là người nói được làm được
# Tình không cần may mắn
# Tình cần nỗ lực
# Tình biến áp lực thành động lực
# Tình biến khó khăn thành bàn đạp
# Tình không ngại mồ hôi
# Tình ngại lãng phí thời gian
# Tình làm việc với kỷ luật thép
# Tình có tinh thần thép
# Tình không lãng phí tuổi trẻ
# Tình sống để tạo giá trị
# Tình không để ai quyết định thay mình
# Tình là người cầm lái cuộc đời
# Tình không ngừng học hỏi
# Tình không ngừng nâng cấp
# Tình có tầm nhìn chiến lược
# Tình luôn đi trước một bước
# Tình không ngại bắt đầu lại
# Tình miễn là còn thở là còn tiến
# Tình không cần sự thương hại
# Tình cần thử thách
# Tình luôn giữ vững lập trường
# Tình không bị cuốn theo đám đông
# Tình là người tạo khác biệt
# Tình không dễ bị đánh giá thấp
# Tình là người càng ép càng bật
# Tình không thích nói nhiều
# Tình thích hành động
# Tình không sợ thất bại
# Tình sợ không dám thử
# Tình sống là phải đáng nhớ
# Tình không để đời mình trôi qua vô nghĩa
# Tình có bản lĩnh của người tiên phong
# Tình không ngại va chạm
# Tình không né tránh thử thách
# Tình luôn tiến công chứ không phòng thủ
# Tình giữ được cái tôi nhưng không ngạo mạn
# Tình có khí chất tự nhiên
# Tình càng lớn càng trầm
# Tình càng mạnh càng khiêm tốn
# Tình không cần spotlight
# Tình tự là spotlight
# Tình không để ai quyết định giới hạn của mình
# Tình không ngừng bứt phá
# Tình luôn giữ lửa trong tim
# Tình có phong cách của nhà vô địch
# Tình không bỏ cuộc giữa chừng
# Tình đi đến cùng mục tiêu
# Tình không cần đường dễ
# Tình chọn đường khó để trưởng thành
# Tình càng vấp ngã càng hiểu mình mạnh cỡ nào
# Tình luôn giữ sự bình tĩnh trong hỗn loạn
# Tình không bao giờ đánh mất chính mình
# Tình có cái đầu sắc bén
# Tình có trái tim dũng cảm
# Tình không bị định nghĩa bởi lời người khác
# Tình tự viết nên câu chuyện của mình
# Tình không để thời gian trôi phí
# Tình tận dụng từng phút từng giây
# Tình sống là phải bùng cháy
# Tình là người không ngừng tiến hóa
# Tình không lùi lại khi bị nghi ngờ
# Tình tiến lên khi bị thách thức
# Tình luôn giữ phong độ ổn định
# Tình là người đáng gờm
# Tình không dễ bị vượt mặt
# Tình có tinh thần cạnh tranh lành mạnh
# Tình luôn giữ được cái chất riêng
# Tình là người khiến người khác phải dè chừng
# Tình không để cảm xúc làm mờ lý trí
# Tình có bản lĩnh thép
# Tình không ngừng tạo ra phiên bản mạnh hơn
# Tình luôn giữ được sự tự chủ
# Tình là người kiểm soát cuộc chơi
# Tình không bị áp lực đè bẹp
# Tình dùng áp lực để luyện mình
# Tình không sợ sai
# Tình sợ không dám sửa
# Tình sống là phải đáng giá
# Tình luôn giữ lời hứa với chính mình
# Tình không để mục tiêu chỉ nằm trên giấy
# Tình biến mục tiêu thành hiện thực
# Tình không ngừng rèn luyện bản thân
# Tình là người càng rèn càng sắc
# Tình không cần hoàn hảo
# Tình cần tiến bộ
# Tình luôn giữ tinh thần máu lửa
# Tình không chấp nhận sự tầm thường
# Tình là người có tiêu chuẩn cao
# Tình không ngại đặt mục tiêu lớn
# Tình càng lớn mục tiêu càng lớn
# Tình không để ai làm chậm bước chân mình
# Tình là người có tốc độ riêng
# Tình luôn giữ được cái tâm vững vàng
# Tình không dễ bị lung lay bởi lời chê
# Tình biến lời chê thành động lực
# Tình không cần phải hơn ai
# Tình chỉ cần hơn chính mình hôm qua
# Tình luôn nâng chuẩn bản thân
# Tình là người không bao giờ dậm chân tại chỗ
# Tình không để cơ hội vuột khỏi tay
# Tình nắm lấy và làm tới cùng
# Tình có tinh thần không bao giờ gục ngã
# Tình sống với khí chất của người đứng đầu
# Tình luôn giữ được bản sắc riêng
# Tình không dễ bị sao chép
# Tình là phiên bản độc nhất
# Tình không đợi hoàn hảo mới bắt đầu
# Tình bắt đầu rồi hoàn thiện dần
# Tình là người không sợ áp lực dư luận
# Tình luôn tập trung vào mục tiêu
# Tình không để mình bị xao nhãng
# Tình có kỷ luật cao
# Tình luôn giữ vững phong thái
# Tình là người càng lớn càng mạnh
# Tình không ngừng tiến bước
# Tình là chiến binh của chính cuộc đời mình
# Tình là một người tuyệt vời
# Tình luôn mang lại năng lượng tích cực
# Tình thông minh và sáng tạo
# Tình có ý chí mạnh mẽ
# Tình không bao giờ bỏ cuộc
# Tình luôn cố gắng mỗi ngày
# Tình có trái tim ấm áp
# Tình rất chân thành
# Tình sống có trách nhiệm
# Tình biết quan tâm người khác
# Tình luôn học hỏi không ngừng
# Tình có tư duy nhanh nhạy
# Tình rất kiên trì
# Tình có tinh thần cầu tiến
# Tình luôn biết cách vượt qua khó khăn
# Tình là người đáng tin cậy
# Tình có phong cách riêng biệt
# Tình rất bản lĩnh
# Tình có suy nghĩ tích cực
# Tình là người có mục tiêu rõ ràng
# Tình làm việc rất chăm chỉ
# Tình không ngại thử thách
# Tình có tinh thần lãnh đạo
# Tình truyền cảm hứng cho người khác
# Tình luôn giữ lời hứa
# Tình sống chân thật
# Tình có tinh thần trách nhiệm cao
# Tình luôn biết lắng nghe
# Tình có tư duy logic tốt
# Tình rất sáng dạ
# Tình là người có nghị lực
# Tình biết cách quản lý thời gian
# Tình luôn tiến bộ từng ngày
# Tình có thái độ sống tích cực
# Tình rất quyết đoán
# Tình có khả năng thích nghi tốt
# Tình là người đáng quý
# Tình luôn biết tôn trọng người khác
# Tình có khả năng học nhanh
# Tình không sợ thất bại
# Tình luôn đứng dậy sau vấp ngã
# Tình có tinh thần chiến đấu mạnh mẽ
# Tình luôn tin vào bản thân
# Tình là người có giá trị
# Tình sống có lý tưởng
# Tình luôn hướng tới thành công
# Tình có tư duy phát triển
# Tình rất kiên định
# Tình luôn biết ơn cuộc sống
# Tình là người đầy tiềm năng
# Tình có trái tim mạnh mẽ
# Tình luôn dám nghĩ dám làm
# Tình rất thông minh
# Tình có tầm nhìn xa
# Tình luôn cố gắng hoàn thiện bản thân
# Tình là người đáng ngưỡng mộ
# Tình luôn giữ vững lập trường
# Tình có cá tính mạnh
# Tình biết cách tạo động lực cho mình
# Tình rất đáng trân trọng
# Tình có nội lực lớn
# Tình luôn giữ thái độ tích cực
# Tình có khả năng giải quyết vấn đề tốt
# Tình rất nhiệt huyết
# Tình luôn biết cách cải thiện bản thân
# Tình sống có đam mê
# Tình là người đầy nghị lực
# Tình luôn đặt mục tiêu cao
# Tình có tư duy linh hoạt
# Tình rất thông thái
# Tình luôn giữ được sự bình tĩnh
# Tình có lòng tự trọng cao
# Tình rất đáng tin
# Tình luôn tỏa sáng theo cách riêng
# Tình có tinh thần trách nhiệm
# Tình luôn suy nghĩ tích cực
# Tình là người sống có chiều sâu
# Tình rất kiên nhẫn
# Tình luôn giữ sự tập trung
# Tình có thái độ chuyên nghiệp
# Tình rất đáng yêu theo cách riêng
# Tình luôn biết điều chỉnh bản thân
# Tình có sự quyết tâm mạnh mẽ
# Tình rất bản lĩnh trong mọi tình huống
# Tình luôn biết vượt qua giới hạn
# Tình có năng lượng mạnh mẽ
# Tình luôn giữ vững niềm tin
# Tình là người đầy khát vọng
# Tình có tinh thần tự lập
# Tình rất chăm chỉ
# Tình luôn tìm cách tiến lên
# Tình có tinh thần học hỏi cao
# Tình luôn giữ được sự kiên trì
# Tình là người có hoài bão lớn
# Tình luôn hướng đến điều tốt đẹp
# Tình có tinh thần mạnh mẽ
# Tình rất thông minh trong suy nghĩ
# Tình luôn giữ được động lực
# Tình có khả năng tạo ra giá trị
# Tình rất đáng tự hào
# Tình luôn phát triển từng ngày
# Tình có cá tính độc đáo
# Tình luôn biết tự hoàn thiện
# Tình là người rất đặc biệt
# Tình luôn nỗ lực hết mình
# Tình có sức mạnh nội tâm lớn
# Tình rất quyết tâm
# Tình luôn tràn đầy hi vọng
# Tình có khả năng thành công lớn
# Tình luôn biết mình muốn gì
# Tình là người có bản sắc riêng
# Tình luôn dũng cảm tiến bước
# Tình có tư duy sáng tạo
# Tình rất kiên cường
# Tình luôn giữ được tinh thần lạc quan
# Tình có tương lai rộng mở
# Tình luôn tạo ra cơ hội cho mình
# Tình là người có sức hút riêng
# Tình luôn sống hết mình
# Tình có phẩm chất tốt đẹp
# Tình rất xứng đáng với thành công
# Tình luôn biết trân trọng bản thân
# Tình có tiềm năng vô hạn
# Tình luôn giữ được lòng tự tin
# Tình là người đầy bản lĩnh
# Tình luôn hướng về phía trước
# Tình có tinh thần cầu tiến mạnh mẽ
# Tình rất xuất sắc
# Tình luôn làm tốt vai trò của mình
# Tình có sức mạnh ý chí lớn
# Tình luôn tin tưởng vào tương lai
# Tình là người đáng được tôn trọng
# Tình luôn tỏa ra năng lượng tích cực
# Tình có khả năng chinh phục thử thách
# Tình rất giỏi theo cách riêng
# Tình luôn nâng cấp bản thân mỗi ngày
# Tình có tư duy thành công
# Tình luôn giữ vững mục tiêu
# Tình là người rất đáng quý
# Tình luôn tự hào về chính mình
# Tình có khả năng bứt phá mạnh mẽ
# Tình luôn biết cách tiến xa hơn
# Tình là phiên bản tốt nhất của chính mình
from prettytable import PrettyTable
import threading
import time
import json
import requests
import subprocess
import sqlite3
import shutil
import pytz
import traceback
import random
import psutil
import sys
import gc
import os
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
from rich.align import Align
from rich.box import ROUNDED
from rich.console import Console
from datetime import datetime, timezone
from threading import Lock, Event
from psutil import boot_time, process_iter, cpu_percent, virtual_memory, Process, NoSuchProcess, AccessDenied, ZombieProcess
package_lock = Lock()
status_lock = Lock()
rejoin_lock = Lock()
bot_instance = None
bot_thread = None
socket_server = None
stop_webhook_thread = False
webhook_thread = None
webhook_url = None
device_name = None
webhook_interval = None
reset_tab_interval = None
close_and_rejoin_delay = None
boot_time = boot_time()
auto_android_id_enabled = False
auto_android_id_thread = None
auto_android_id_value = None
globals()["_disable_ui"] = "0"
globals()["package_statuses"] = {}
globals()["_uid_"] = {}
globals()["_user_"] = {}
globals()["is_runner_ez"] = False
globals()["check_exec_enable"] = "1"
executors = {
    "Fluxus": "/storage/emulated/0/Fluxus/",
    "Fluxus Clone 001": "/storage/emulated/0/RobloxClone001/Fluxus/",
    "Fluxus Clone 002": "/storage/emulated/0/RobloxClone002/Fluxus/",
    "Fluxus Clone 003": "/storage/emulated/0/RobloxClone003/Fluxus/",
    "Fluxus Clone 004": "/storage/emulated/0/RobloxClone004/Fluxus/",
    "Fluxus Clone 005": "/storage/emulated/0/RobloxClone005/Fluxus/",
    "Fluxus Clone 006": "/storage/emulated/0/RobloxClone006/Fluxus/",
    "Fluxus Clone 007": "/storage/emulated/0/RobloxClone007/Fluxus/",
    "Fluxus Clone 008": "/storage/emulated/0/RobloxClone008/Fluxus/",
    "Fluxus Clone 009": "/storage/emulated/0/RobloxClone009/Fluxus/",
    "Fluxus Clone 010": "/storage/emulated/0/RobloxClone010/Fluxus/",
    "Fluxus Clone 011": "/storage/emulated/0/RobloxClone011/Fluxus/",
    "Fluxus Clone 012": "/storage/emulated/0/RobloxClone012/Fluxus/",
    "Fluxus Clone 013": "/storage/emulated/0/RobloxClone013/Fluxus/",
    "Fluxus Clone 014": "/storage/emulated/0/RobloxClone014/Fluxus/",
    "Fluxus Clone 015": "/storage/emulated/0/RobloxClone015/Fluxus/",
    "Fluxus Clone 016": "/storage/emulated/0/RobloxClone016/Fluxus/",
    "Fluxus Clone 017": "/storage/emulated/0/RobloxClone017/Fluxus/",
    "Fluxus Clone 018": "/storage/emulated/0/RobloxClone018/Fluxus/",
    "Fluxus Clone 019": "/storage/emulated/0/RobloxClone019/Fluxus/",
    "Fluxus Clone 020": "/storage/emulated/0/RobloxClone020/Fluxus/",
    "Codex": "/storage/emulated/0/Codex/",
    "Codex Clone 001": "/storage/emulated/0/RobloxClone001/Codex/",
    "Codex Clone 002": "/storage/emulated/0/RobloxClone002/Codex/",
    "Codex Clone 003": "/storage/emulated/0/RobloxClone003/Codex/",
    "Codex Clone 004": "/storage/emulated/0/RobloxClone004/Codex/",
    "Codex Clone 005": "/storage/emulated/0/RobloxClone005/Codex/",
    "Codex Clone 006": "/storage/emulated/0/RobloxClone006/Codex/",
    "Codex Clone 007": "/storage/emulated/0/RobloxClone007/Codex/",
    "Codex Clone 008": "/storage/emulated/0/RobloxClone008/Codex/",
    "Codex Clone 009": "/storage/emulated/0/RobloxClone009/Codex/",
    "Codex Clone 010": "/storage/emulated/0/RobloxClone010/Codex/",
    "Codex Clone 011": "/storage/emulated/0/RobloxClone011/Codex/",
    "Codex Clone 012": "/storage/emulated/0/RobloxClone012/Codex/",
    "Codex Clone 013": "/storage/emulated/0/RobloxClone013/Codex/",
    "Codex Clone 014": "/storage/emulated/0/RobloxClone014/Codex/",
    "Codex Clone 015": "/storage/emulated/0/RobloxClone015/Codex/",
    "Codex Clone 016": "/storage/emulated/0/RobloxClone016/Codex/",
    "Codex Clone 017": "/storage/emulated/0/RobloxClone017/Codex/",
    "Codex Clone 018": "/storage/emulated/0/RobloxClone018/Codex/",
    "Codex Clone 019": "/storage/emulated/0/RobloxClone019/Codex/",
    "Codex Clone 020": "/storage/emulated/0/RobloxClone020/Codex/",
    "Codex VNG Clone 001": "/storage/emulated/0/RobloxVNGClone001/Codex/",
    "Codex VNG Clone 002": "/storage/emulated/0/RobloxVNGClone002/Codex/",
    "Codex VNG Clone 003": "/storage/emulated/0/RobloxVNGClone003/Codex/",
    "Codex VNG Clone 004": "/storage/emulated/0/RobloxVNGClone004/Codex/",
    "Codex VNG Clone 005": "/storage/emulated/0/RobloxVNGClone005/Codex/",
    "Codex VNG Clone 006": "/storage/emulated/0/RobloxVNGClone006/Codex/",
    "Codex VNG Clone 007": "/storage/emulated/0/RobloxVNGClone007/Codex/",
    "Codex VNG Clone 008": "/storage/emulated/0/RobloxVNGClone008/Codex/",
    "Codex VNG Clone 009": "/storage/emulated/0/RobloxVNGClone009/Codex/",
    "Codex VNG Clone 010": "/storage/emulated/0/RobloxVNGClone010/Codex/",
    "Codex VNG Clone 011": "/storage/emulated/0/RobloxVNGClone011/Codex/",
    "Codex VNG Clone 012": "/storage/emulated/0/RobloxVNGClone012/Codex/",
    "Codex VNG Clone 013": "/storage/emulated/0/RobloxVNGClone013/Codex/",
    "Codex VNG Clone 014": "/storage/emulated/0/RobloxVNGClone014/Codex/",
    "Codex VNG Clone 015": "/storage/emulated/0/RobloxVNGClone015/Codex/",
    "Codex VNG Clone 016": "/storage/emulated/0/RobloxVNGClone016/Codex/",
    "Codex VNG Clone 017": "/storage/emulated/0/RobloxVNGClone017/Codex/",
    "Codex VNG Clone 018": "/storage/emulated/0/RobloxVNGClone018/Codex/",
    "Codex VNG Clone 019": "/storage/emulated/0/RobloxVNGClone019/Codex/",
    "Codex VNG Clone 020": "/storage/emulated/0/RobloxVNGClone020/Codex/",
    "Arceus X": "/storage/emulated/0/Arceus X/",
    "Arceus X Clone 001": "/storage/emulated/0/RobloxClone001/Arceus X/",
    "Arceus X Clone 002": "/storage/emulated/0/RobloxClone002/Arceus X/",
    "Arceus X Clone 003": "/storage/emulated/0/RobloxClone003/Arceus X/",
    "Arceus X Clone 004": "/storage/emulated/0/RobloxClone004/Arceus X/",
    "Arceus X Clone 005": "/storage/emulated/0/RobloxClone005/Arceus X/",
    "Arceus X Clone 006": "/storage/emulated/0/RobloxClone006/Arceus X/",
    "Arceus X Clone 007": "/storage/emulated/0/RobloxClone007/Arceus X/",
    "Arceus X Clone 008": "/storage/emulated/0/RobloxClone008/Arceus X/",
    "Arceus X Clone 009": "/storage/emulated/0/RobloxClone009/Arceus X/",
    "Arceus X Clone 010": "/storage/emulated/0/RobloxClone010/Arceus X/",
    "Arceus X Clone 011": "/storage/emulated/0/RobloxClone011/Arceus X/",
    "Arceus X Clone 012": "/storage/emulated/0/RobloxClone012/Arceus X/",
    "Arceus X Clone 013": "/storage/emulated/0/RobloxClone013/Arceus X/",
    "Arceus X Clone 014": "/storage/emulated/0/RobloxClone014/Arceus X/",
    "Arceus X Clone 015": "/storage/emulated/0/RobloxClone015/Arceus X/",
    "Arceus X Clone 016": "/storage/emulated/0/RobloxClone016/Arceus X/",
    "Arceus X Clone 017": "/storage/emulated/0/RobloxClone017/Arceus X/",
    "Arceus X Clone 018": "/storage/emulated/0/RobloxClone018/Arceus X/",
    "Arceus X Clone 019": "/storage/emulated/0/RobloxClone019/Arceus X/",
    "Arceus X Clone 020": "/storage/emulated/0/RobloxClone020/Arceus X/",
    "Arceus X VNG Clone 001": "/storage/emulated/0/RobloxVNGClone001/Arceus X/",
    "Arceus X VNG Clone 002": "/storage/emulated/0/RobloxVNGClone002/Arceus X/",
    "Arceus X VNG Clone 003": "/storage/emulated/0/RobloxVNGClone003/Arceus X/",
    "Arceus X VNG Clone 004": "/storage/emulated/0/RobloxVNGClone004/Arceus X/",
    "Arceus X VNG Clone 005": "/storage/emulated/0/RobloxVNGClone005/Arceus X/",
    "Arceus X VNG Clone 006": "/storage/emulated/0/RobloxVNGClone006/Arceus X/",
    "Arceus X VNG Clone 007": "/storage/emulated/0/RobloxVNGClone007/Arceus X/",
    "Arceus X VNG Clone 008": "/storage/emulated/0/RobloxVNGClone008/Arceus X/",
    "Arceus X VNG Clone 009": "/storage/emulated/0/RobloxVNGClone009/Arceus X/",
    "Arceus X VNG Clone 010": "/storage/emulated/0/RobloxVNGClone010/Arceus X/",
    "Arceus X VNG Clone 011": "/storage/emulated/0/RobloxVNGClone011/Arceus X/",
    "Arceus X VNG Clone 012": "/storage/emulated/0/RobloxVNGClone012/Arceus X/",
    "Arceus X VNG Clone 013": "/storage/emulated/0/RobloxVNGClone013/Arceus X/",
    "Arceus X VNG Clone 014": "/storage/emulated/0/RobloxVNGClone014/Arceus X/",
    "Arceus X VNG Clone 015": "/storage/emulated/0/RobloxVNGClone015/Arceus X/",
    "Arceus X VNG Clone 016": "/storage/emulated/0/RobloxVNGClone016/Arceus X/",
    "Arceus X VNG Clone 017": "/storage/emulated/0/RobloxVNGClone017/Arceus X/",
    "Arceus X VNG Clone 018": "/storage/emulated/0/RobloxVNGClone018/Arceus X/",
    "Arceus X VNG Clone 019": "/storage/emulated/0/RobloxVNGClone019/Arceus X/",
    "Arceus X VNG Clone 020": "/storage/emulated/0/RobloxVNGClone020/Arceus X/",
    "RonixExploit": "/storage/emulated/0/RonixExploit/",
    "RonixExploit Clone 001": "/storage/emulated/0/RobloxClone001/RonixExploit/",
    "RonixExploit Clone 002": "/storage/emulated/0/RobloxClone002/RonixExploit/",
    "RonixExploit Clone 003": "/storage/emulated/0/RobloxClone003/RonixExploit/",
    "RonixExploit Clone 004": "/storage/emulated/0/RobloxClone004/RonixExploit/",
    "RonixExploit Clone 005": "/storage/emulated/0/RobloxClone005/RonixExploit/",
    "RonixExploit Clone 006": "/storage/emulated/0/RobloxClone006/RonixExploit/",
    "RonixExploit Clone 007": "/storage/emulated/0/RobloxClone007/RonixExploit/",
    "RonixExploit Clone 008": "/storage/emulated/0/RobloxClone008/RonixExploit/",
    "RonixExploit Clone 009": "/storage/emulated/0/RobloxClone009/RonixExploit/",
    "RonixExploit Clone 010": "/storage/emulated/0/RobloxClone010/RonixExploit/",
    "RonixExploit Clone 011": "/storage/emulated/0/RobloxClone011/RonixExploit/",
    "RonixExploit Clone 012": "/storage/emulated/0/RobloxClone012/RonixExploit/",
    "RonixExploit Clone 013": "/storage/emulated/0/RobloxClone013/RonixExploit/",
    "RonixExploit Clone 014": "/storage/emulated/0/RobloxClone014/RonixExploit/",
    "RonixExploit Clone 015": "/storage/emulated/0/RobloxClone015/RonixExploit/",
    "RonixExploit Clone 016": "/storage/emulated/0/RobloxClone016/RonixExploit/",
    "RonixExploit Clone 017": "/storage/emulated/0/RobloxClone017/RonixExploit/",
    "RonixExploit Clone 018": "/storage/emulated/0/RobloxClone018/RonixExploit/",
    "RonixExploit Clone 019": "/storage/emulated/0/RobloxClone019/RonixExploit/",
    "RonixExploit Clone 020": "/storage/emulated/0/RobloxClone020/RonixExploit/",
    "RonixExploit VNG Clone 001": "/storage/emulated/0/RobloxVNGClone001/RonixExploit/",
    "RonixExploit VNG Clone 002": "/storage/emulated/0/RobloxVNGClone002/RonixExploit/",
    "RonixExploit VNG Clone 003": "/storage/emulated/0/RobloxVNGClone003/RonixExploit/",
    "RonixExploit VNG Clone 004": "/storage/emulated/0/RobloxVNGClone004/RonixExploit/",
    "RonixExploit VNG Clone 005": "/storage/emulated/0/RobloxVNGClone005/RonixExploit/",
    "RonixExploit VNG Clone 006": "/storage/emulated/0/RobloxVNGClone006/RonixExploit/",
    "RonixExploit VNG Clone 007": "/storage/emulated/0/RobloxVNGClone007/RonixExploit/",
    "RonixExploit VNG Clone 008": "/storage/emulated/0/RobloxVNGClone008/RonixExploit/",
    "RonixExploit VNG Clone 009": "/storage/emulated/0/RobloxVNGClone009/RonixExploit/",
    "RonixExploit VNG Clone 010": "/storage/emulated/0/RobloxVNGClone010/RonixExploit/",
    "RonixExploit VNG Clone 011": "/storage/emulated/0/RobloxVNGClone011/RonixExploit/",
    "RonixExploit VNG Clone 012": "/storage/emulated/0/RobloxVNGClone012/RonixExploit/",
    "RonixExploit VNG Clone 013": "/storage/emulated/0/RobloxVNGClone013/RonixExploit/",
    "RonixExploit VNG Clone 014": "/storage/emulated/0/RobloxVNGClone014/RonixExploit/",
    "RonixExploit VNG Clone 015": "/storage/emulated/0/RobloxVNGClone015/RonixExploit/",
    "RonixExploit VNG Clone 016": "/storage/emulated/0/RobloxVNGClone016/RonixExploit/",
    "RonixExploit VNG Clone 017": "/storage/emulated/0/RobloxVNGClone017/RonixExploit/",
    "RonixExploit VNG Clone 018": "/storage/emulated/0/RobloxVNGClone018/RonixExploit/",
    "RonixExploit VNG Clone 019": "/storage/emulated/0/RobloxVNGClone019/RonixExploit/",
    "RonixExploit VNG Clone 020": "/storage/emulated/0/RobloxVNGClone020/RonixExploit/",
    "Delta": "/storage/emulated/0/Delta/",
    "Delta Clone 001": "/storage/emulated/0/RobloxClone001/Delta/",
    "Delta Clone 002": "/storage/emulated/0/RobloxClone002/Delta/",
    "Delta Clone 003": "/storage/emulated/0/RobloxClone003/Delta/",
    "Delta Clone 004": "/storage/emulated/0/RobloxClone004/Delta/",
    "Delta Clone 005": "/storage/emulated/0/RobloxClone005/Delta/",
    "Delta Clone 006": "/storage/emulated/0/RobloxClone006/Delta/",
    "Delta Clone 007": "/storage/emulated/0/RobloxClone007/Delta/",
    "Delta Clone 008": "/storage/emulated/0/RobloxClone008/Delta/",
    "Delta Clone 009": "/storage/emulated/0/RobloxClone009/Delta/",
    "Delta Clone 010": "/storage/emulated/0/RobloxClone010/Delta/",
    "Delta Clone 011": "/storage/emulated/0/RobloxClone011/Delta/",
    "Delta Clone 012": "/storage/emulated/0/RobloxClone012/Delta/",
    "Delta Clone 013": "/storage/emulated/0/RobloxClone013/Delta/",
    "Delta Clone 014": "/storage/emulated/0/RobloxClone014/Delta/",
    "Delta Clone 015": "/storage/emulated/0/RobloxClone015/Delta/",
    "Delta Clone 016": "/storage/emulated/0/RobloxClone016/Delta/",
    "Delta Clone 017": "/storage/emulated/0/RobloxClone017/Delta/",
    "Delta Clone 018": "/storage/emulated/0/RobloxClone018/Delta/",
    "Delta Clone 019": "/storage/emulated/0/RobloxClone019/Delta/",
    "Delta Clone 020": "/storage/emulated/0/RobloxClone020/Delta/",
    "Cryptic": "/storage/emulated/0/Cryptic/",
    "Cryptic Clone 001": "/storage/emulated/0/RobloxClone001/Cryptic/",
    "Cryptic Clone 002": "/storage/emulated/0/RobloxClone002/Cryptic/",
    "Cryptic Clone 003": "/storage/emulated/0/RobloxClone003/Cryptic/",
    "Cryptic Clone 004": "/storage/emulated/0/RobloxClone004/Cryptic/",
    "Cryptic Clone 005": "/storage/emulated/0/RobloxClone005/Cryptic/",
    "Cryptic Clone 006": "/storage/emulated/0/RobloxClone006/Cryptic/",
    "Cryptic Clone 007": "/storage/emulated/0/RobloxClone007/Cryptic/",
    "Cryptic Clone 008": "/storage/emulated/0/RobloxClone008/Cryptic/",
    "Cryptic Clone 009": "/storage/emulated/0/RobloxClone009/Cryptic/",
    "Cryptic Clone 010": "/storage/emulated/0/RobloxClone010/Cryptic/",
    "Cryptic Clone 011": "/storage/emulated/0/RobloxClone011/Cryptic/",
    "Cryptic Clone 012": "/storage/emulated/0/RobloxClone012/Cryptic/",
    "Cryptic Clone 013": "/storage/emulated/0/RobloxClone013/Cryptic/",
    "Cryptic Clone 014": "/storage/emulated/0/RobloxClone014/Cryptic/",
    "Cryptic Clone 015": "/storage/emulated/0/RobloxClone015/Cryptic/",
    "Cryptic Clone 016": "/storage/emulated/0/RobloxClone016/Cryptic/",
    "Cryptic Clone 017": "/storage/emulated/0/RobloxClone017/Cryptic/",
    "Cryptic Clone 018": "/storage/emulated/0/RobloxClone018/Cryptic/",
    "Cryptic Clone 019": "/storage/emulated/0/RobloxClone019/Cryptic/",
    "Cryptic Clone 020": "/storage/emulated/0/RobloxClone020/Cryptic/",
    "KRNL": "/storage/emulated/0/krnl/",
    "Trigon": "/storage/emulated/0/Trigon/",
    "FrostWare": "/storage/emulated/0/FrostWare/",
    "FrostWare Clone 001": "/storage/emulated/0/RobloxClone001/FrostWare/",
    "FrostWare Clone 002": "/storage/emulated/0/RobloxClone002/FrostWare/",
    "FrostWare Clone 003": "/storage/emulated/0/RobloxClone003/FrostWare/",
    "FrostWare Clone 004": "/storage/emulated/0/RobloxClone004/FrostWare/",
    "FrostWare Clone 005": "/storage/emulated/0/RobloxClone005/FrostWare/",
    "FrostWare Clone 006": "/storage/emulated/0/RobloxClone006/FrostWare/",
    "FrostWare Clone 007": "/storage/emulated/0/RobloxClone007/FrostWare/",
    "FrostWare Clone 008": "/storage/emulated/0/RobloxClone008/FrostWare/",
    "FrostWare Clone 009": "/storage/emulated/0/RobloxClone009/FrostWare/",
    "FrostWare Clone 010": "/storage/emulated/0/RobloxClone010/FrostWare/",
    "FrostWare Clone 011": "/storage/emulated/0/RobloxClone011/FrostWare/",
    "FrostWare Clone 012": "/storage/emulated/0/RobloxClone012/FrostWare/",
    "FrostWare Clone 013": "/storage/emulated/0/RobloxClone013/FrostWare/",
    "FrostWare Clone 014": "/storage/emulated/0/RobloxClone014/FrostWare/",
    "FrostWare Clone 015": "/storage/emulated/0/RobloxClone015/FrostWare/",
    "FrostWare Clone 016": "/storage/emulated/0/RobloxClone016/FrostWare/",
    "FrostWare Clone 017": "/storage/emulated/0/RobloxClone017/FrostWare/",
    "FrostWare Clone 018": "/storage/emulated/0/RobloxClone018/FrostWare/",
    "FrostWare Clone 019": "/storage/emulated/0/RobloxClone019/FrostWare/",
    "FrostWare Clone 020": "/storage/emulated/0/RobloxClone020/FrostWare/",
    "Evon": "/storage/emulated/0/Evon/",
}
workspace_paths = [f"{base_path}Workspace" for base_path in executors.values()] + \
                  [f"{base_path}workspace" for base_path in executors.values()]
globals()["workspace_paths"] = workspace_paths
globals()["executors"] = executors
if not os.path.exists("ZeroNokami"):
    os.makedirs("ZeroNokami", exist_ok=True)
SERVER_LINKS_FILE = "ZeroNokami/server-links.txt"
ACCOUNTS_FILE = "ZeroNokami/accounts.txt"
CONFIG_FILE = "ZeroNokami/config.json"
version = "3.6.7 | By ZeroNokami | Bug Fixes By ZeroNokami"
class Utilities:
    @staticmethod
    def collect_garbage():
        gc.collect()
    @staticmethod
    def log_error(error_message):
        with open("error_log.txt", "a") as error_log:
            error_log.write(f"{error_message}\n\n")
    @staticmethod
    def clear_screen():
        os.system('cls' if os.name == 'nt' else 'clear')
    @staticmethod
    def get_hwid_codex():
        return subprocess.run(["settings", "get", "secure", "android_id"], capture_output=True, text=True, check=True).stdout.strip()
    @staticmethod
    def calculate_time_left(expiry_timestamp):
        current_time = int(time.time())
        time_left = expiry_timestamp / 1000 - current_time
        return time_left
    @staticmethod
    def format_time_left(time_left):
        hours, remainder = divmod(time_left, 3600)
        minutes, seconds = divmod(remainder, 60)
        return f"{int(hours):02} hour(s) {int(minutes):02} minute(s) {int(seconds):02} second(s)"
    @staticmethod
    def convert_to_ho_chi_minh_time(expiry_timestamp):
        ho_chi_minh_tz = pytz.timezone("Asia/Ho_Chi_Minh")
        expiry_datetime = datetime.fromtimestamp(expiry_timestamp / 1000, pytz.utc)
        expiry_datetime = expiry_datetime.astimezone(ho_chi_minh_tz)
        return expiry_datetime.strftime("%Y-%m-%d %H:%M:%S")
class FileManager:
    SERVER_LINKS_FILE = "ZeroNokami/server-link.txt"
    ACCOUNTS_FILE = "ZeroNokami/account.txt"
    CONFIG_FILE = "ZeroNokami/config-wh.json"
    @staticmethod
    def setup_user_ids():
        print("\033[1;32m[ ZeroNokami ] - Auto-detecting User IDs from app packages...\033[0m")
        packages = RobloxManager.get_roblox_packages()
        accounts = []
        if not packages:
            print("\033[1;31m[ ZeroNokami ] - No Roblox packages detected to set up User IDs.\033[0m")
            return []
        for package_name in packages:
            file_path = f'/data/data/{package_name}/files/appData/LocalStorage/appStorage.json'
            try:
                user_id = FileManager.find_userid_from_file(file_path)
                if user_id and user_id != "-1":
                    accounts.append((package_name, user_id))
                    print(f"\033[96m[ ZeroNokami ] - Found UserID for {package_name}: {user_id}\033[0m")
                else:
                    print(f"\033[1;31m[ ZeroNokami ] - UserID not found for {package_name}.\033[0m")
            except Exception as e:
                print(f"\033[1;31m[ ZeroNokami ] - Error reading file for {package_name}: {e}\033[0m")
                Utilities.log_error(f"Error reading appStorage.json for {package_name}: {e}")
        if accounts:
            FileManager.save_accounts(accounts)
            print("\033[1;32m[ ZeroNokami ] - User IDs have been successfully saved.\033[0m")
        else:
            print("\033[1;31m[ ZeroNokami ] - Could not find any valid User IDs to set up.\033[0m")
       
        return accounts
    @staticmethod
    def save_server_links(server_links):
        try:
            os.makedirs(os.path.dirname(FileManager.SERVER_LINKS_FILE), exist_ok=True)
            with open(FileManager.SERVER_LINKS_FILE, "w") as file:
                for package, link in server_links:
                    file.write(f"{package},{link}\n")
            print("\033[1;32m[ ZeroNokami ] - Server links saved successfully.\033[0m")
        except IOError as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error saving server links: {e}\033[0m")
            Utilities.log_error(f"Error saving server links: {e}")
    @staticmethod
    def load_server_links():
        server_links = []
        if os.path.exists(FileManager.SERVER_LINKS_FILE):
            with open(FileManager.SERVER_LINKS_FILE, "r") as file:
                for line in file:
                    package, link = line.strip().split(",", 1)
                    server_links.append((package, link))
        return server_links
    @staticmethod
    def save_accounts(accounts):
        with open(FileManager.ACCOUNTS_FILE, "w") as file:
            for package, user_id in accounts:
                file.write(f"{package},{user_id}\n")
    @staticmethod
    def load_accounts():
        accounts = []
        if os.path.exists(FileManager.ACCOUNTS_FILE):
            with open(FileManager.ACCOUNTS_FILE, "r") as file:
                for line in file:
                    line = line.strip()
                    if line:
                        try:
                            package, user_id = line.split(",", 1)
                            globals()["_user_"][package] = user_id
                            accounts.append((package, user_id))
                        except ValueError:
                            print(f"\033[1;31m[ ZeroNokami ] - Invalid line format: {line}. Expected format 'package,user_id'.\033[0m")
        return accounts
    @staticmethod
    def find_userid_from_file(file_path):
        try:
            with open(file_path, 'r') as file:
                content = file.read()
                userid_start = content.find('"UserId":"')
                if userid_start == -1:
                    return None
                userid_start += len('"UserId":"')
                userid_end = content.find('"', userid_start)
                if userid_end == -1:
                    return None
                userid = content[userid_start:userid_end]
                return userid
        except IOError as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error reading file: {e}\033[0m")
            return None
    @staticmethod
    def get_username(user_id):
        user = FileManager.load_saved_username(user_id)
        if user is not None:
            return user
        retry_attempts = 2
        for attempt in range(retry_attempts):
            try:
                url = f"https://users.roblox.com/v1/users/{user_id}"
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                data = response.json()
                username = data.get("name", "Unknown")
                if username != "Unknown":
                    FileManager.save_username(user_id, username)
                    return username
            except requests.exceptions.RequestException as e:
                print(f"\033[1;31m[ ZeroNokami ] - Attempt {attempt + 1} failed for Roblox Users API: {e}\033[0m")
                time.sleep(2 ** attempt)
        for attempt in range(retry_attempts):
            try:
                url = f"https://users.roproxy.com/v1/users/{user_id}"
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                data = response.json()
                username = data.get("name", "Unknown")
                if username != "Unknown":
                    FileManager.save_username(user_id, username)
                    return username
            except requests.exceptions.RequestException as e:
                print(f"\033[1;31m[ ZeroNokami ] - Attempt {attempt + 1} failed for RoProxy API: {e}\033[0m")
                time.sleep(2 ** attempt)
        return "Unknown"
    @staticmethod
    def save_username(user_id, username):
        try:
            if not os.path.exists("usernames.json"):
                with open("usernames.json", "w") as file:
                    json.dump({user_id: username}, file)
            else:
                with open("usernames.json", "r+") as file:
                    try:
                        data = json.load(file)
                    except json.JSONDecodeError:
                        data = {}
                    data[user_id] = username
                    file.seek(0)
                    json.dump(data, file)
                    file.truncate()
        except (IOError, json.JSONDecodeError) as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error saving username: {e}\033[0m")
    @staticmethod
    def load_saved_username(user_id):
        try:
            with open("usernames.json", "r") as file:
                data = json.load(file)
                return data.get(user_id, None)
        except (FileNotFoundError, json.JSONDecodeError, IOError) as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error loading username: {e}\033[0m")
            return None
    @staticmethod
    def download_file(url, destination, binary=False):
        try:
            response = requests.get(url, stream=True)
            if response.status_code == 200:
                mode = 'wb' if binary else 'w'
                with open(destination, mode) as file:
                    if binary:
                        shutil.copyfileobj(response.raw, file)
                    else:
                        file.write(response.text)
                print(f"\033[1;32m[ ZeroNokami ] - {os.path.basename(destination)} downloaded successfully.\033[0m")
                return destination
            else:
                error_message = f"Failed to download {os.path.basename(destination)}. Status code: {response.status_code}"
                print(f"\033[1;31m[ ZeroNokami ] - {error_message}\033[0m")
                Utilities.log_error(error_message)
                return None
        except requests.RequestException as e:
            error_message = f"Request exception while downloading {os.path.basename(destination)}: {e}"
            print(f"\033[1;31m[ ZeroNokami ] - {error_message}\033[0m")
            Utilities.log_error(error_message)
            return None
        except Exception as e:
            error_message = f"Unexpected error while downloading {os.path.basename(destination)}: {e}"
            print(f"\033[1;31m[ ZeroNokami ] - {error_message}\033[0m")
            Utilities.log_error(error_message)
            return None
    @staticmethod
    def _load_config():
        global webhook_url, device_name, webhook_interval, close_and_rejoin_delay, reset_tab_interval
        try:
            if os.path.exists(FileManager.CONFIG_FILE):
                with open(FileManager.CONFIG_FILE, "r") as file:
                    config = json.load(file)
                    webhook_url = config.get("webhook_url", None)
                    device_name = config.get("device_name", None)
                    webhook_interval = config.get("interval", float('inf'))
                    globals()["_disable_ui"] = config.get("disable_ui", "0")
                    globals()["check_exec_enable"] = config.get("check_executor", "1")
                    globals()["command_8_configured"] = config.get("command_8_configured", False)
                    globals()["lua_script_template"] = config.get("lua_script_template", None)
                    globals()["package_prefix"] = config.get("package_prefix", "com.roblox")
                    close_and_rejoin_delay = config.get("close_and_rejoin_delay", None)
                    reset_tab_interval = config.get("reset_tab_interval", None)
            else:
                webhook_url = None
                device_name = None
                webhook_interval = float('inf')
                globals()["_disable_ui"] = "0"
                globals()["check_exec_enable"] = "1"
                globals()["command_8_configured"] = False
                globals()["lua_script_template"] = None
                globals()["package_prefix"] = "com.roblox"
                close_and_rejoin_delay = None
                reset_tab_interval = None
        except Exception as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error loading configuration: {e}\033[0m")
            Utilities.log_error(f"Error loading configuration: {e}")
    @staticmethod
    def save_config():
        try:
            config = {
                "webhook_url": webhook_url,
                "device_name": device_name,
                "interval": webhook_interval,
                "disable_ui": globals().get("_disable_ui", "0"),
                "check_executor": globals()["check_exec_enable"],
                "command_8_configured": globals().get("command_8_configured", False),
                "lua_script_template": globals().get("lua_script_template", None),
                "package_prefix": globals().get("package_prefix", "com.roblox"),
            }
            with open(FileManager.CONFIG_FILE, "w") as file:
                json.dump(config, file, indent=4, sort_keys=True)
            print("\033[1;32m[ ZeroNokami ] - Configuration saved successfully.\033[0m")
        except Exception as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error saving configuration: {e}\033[0m")
            Utilities.log_error(f"Error saving configuration: {e}")
    @staticmethod
    def check_and_create_cookie_file():
        folder_path = os.path.dirname(os.path.abspath(__file__))
        cookie_file_path = os.path.join(folder_path, 'cookie.txt')
        if not os.path.exists(cookie_file_path):
            with open(cookie_file_path, 'w') as f:
                f.write("")
    @staticmethod
    def xuat(db_path):
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT value FROM cookies WHERE host_key = '.roblox.com' AND name = '.ROBLOSECURITY'")
            result = cursor.fetchone()
            conn.close()
            if result:
                return result[0]
            else:
                return None
        except Exception as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error extracting cookie: {e}\033[0m")
            return None
class SystemMonitor:
    @staticmethod
    def capture_screenshot():
        screenshot_path = "/storage/emulated/0/Download/screenshot.png"
        try:
            os.system(f"/system/bin/screencap -p {screenshot_path}")
            if not os.path.exists(screenshot_path):
                raise FileNotFoundError("Screenshot file was not created.")
            return screenshot_path
        except Exception as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error capturing screenshot: {e}\033[0m")
            Utilities.log_error(f"Error capturing screenshot: {e}")
            return None
    @staticmethod
    def get_uptime():
        current_time = time.time()
        uptime_seconds = current_time - psutil.boot_time()
        days = int(uptime_seconds // (24 * 3600))
        hours = int((uptime_seconds % (24 * 3600)) // 3600)
        minutes = int((uptime_seconds % 3600) // 60)
        seconds = int(uptime_seconds % 60)
        return f"{days}d {hours}h {minutes}m {seconds}s"
    @staticmethod
    def roblox_processes():
        package_names = []
        package_namez = RobloxManager.get_roblox_packages()
        for proc in process_iter(['name', 'pid', 'memory_info', 'cpu_percent']):
            try:
                proc_name = proc.info['name']
                for package_name in package_namez:
                    if proc_name.lower() == package_name[-15:].lower():
                        mem_usage = proc.info['memory_info'].rss / (1024 ** 2)
                        mem_usage_rounded = round(mem_usage, 2)
                        cpu_usage = proc.cpu_percent(interval=1) / psutil.cpu_count(logical=True)
                        cpu_usage_rounded = round(cpu_usage, 2)
                        full_name = package_name
                        package_names.append(f"{full_name} (PID: {proc.pid}, CPU: {cpu_usage_rounded}%, MEM: {mem_usage_rounded}MB)")
                        break
            except (NoSuchProcess, AccessDenied, ZombieProcess):
                continue
        return package_names
    @staticmethod
    def get_memory_usage():
        try:
            process = Process(os.getpid())
            mem_info = process.memory_info()
            mem_usage_mb = mem_info.rss / (1024 ** 2)
            return round(mem_usage_mb, 2)
        except Exception as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error getting memory usage: {e}\033[0m")
            Utilities.log_error(f"Error getting memory usage: {e}")
            return None
    @staticmethod
    def get_system_info():
        try:
            cpu_usage = cpu_percent(interval=1)
            memory_info = virtual_memory()
            system_info = {
                "cpu_usage": cpu_usage,
                "memory_total": round(memory_info.total / (1024 ** 3), 2),
                "memory_used": round(memory_info.used / (1024 ** 3), 2),
                "memory_percent": memory_info.percent,
                "uptime": SystemMonitor.get_uptime(),
                "roblox_packages": SystemMonitor.roblox_processes()
            }
            return system_info
        except Exception as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error retrieving system information: {e}\033[0m")
            Utilities.log_error(f"Error retrieving system information: {e}")
            return False
class RobloxManager:
    @staticmethod
    def get_cookie():
        try:
            current_dir = os.getcwd()
            cookie_txt_path = os.path.join(current_dir, "cookie.txt")
            new_dir_path = os.path.join(current_dir, "ZeroNokami/ZeroNokami - Data")
            new_cookie_path = os.path.join(new_dir_path, "cookie.txt")
            if not os.path.exists(new_dir_path):
                os.makedirs(new_dir_path)
            if not os.path.exists(cookie_txt_path):
                print("\033[1;31m[ ZeroNokami ] - cookie.txt not found in the current directory!\033[0m")
                Utilities.log_error("cookie.txt not found in the current directory.")
                return False
            cookies = []
            org = []
            with open(cookie_txt_path, "r") as file:
                for line in file.readlines():
                    parts = str(line).strip().split(":")
                    if len(parts) == 4:
                        ck = ":".join(parts[2:])
                    else:
                        ck = str(line).strip()
                    if ck.startswith("_|WARNING:"):
                        org.append(str(line).strip())
                        cookies.append(ck)
            if len(cookies) == 0:
                print("\033[1;31m[ ZeroNokami ] - No valid cookies found in cookie.txt. Please add cookies.\033[0m")
                Utilities.log_error("No valid cookies found in cookie.txt.")
                return False
            cookie = cookies.pop(0)
            original_line = org.pop(0)
            with open(new_cookie_path, "a") as new_file:
                new_file.write(original_line + "\n")
            with open(cookie_txt_path, "w") as file:
                file.write("\n".join(org))
            return cookie
        except Exception as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error: {e}\033[0m")
            Utilities.log_error(f"Error in get_cookie: {e}")
            return False
    @staticmethod
    def verify_cookie(cookie_value):
        try:
            headers = {
                'Cookie': f'.ROBLOSECURITY={cookie_value}',
                'User-Agent': 'Mozilla/5.0 (Linux; Android 10; Mobile) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Mobile Safari/537.36',
                'Referer': 'https://www.roblox.com/',
                'Origin': 'https://www.roblox.com',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept-Encoding': 'gzip, deflate, br',
                'Connection': 'keep-alive'
            }
            time.sleep(1)
            response = requests.get('https://users.roblox.com/v1/users/authenticated', headers=headers)
            if response.status_code == 200:
                print("\033[1;32m[ ZeroNokami ] - Cookie is valid! User is authenticated.\033[0m")
                return response.json().get("id", False)
            elif response.status_code == 401:
                print("\033[1;31m[ ZeroNokami ] - Invalid cookie. The user is not authenticated.\033[0m")
                return False
            else:
                error_message = f"Error verifying cookie: {response.status_code} - {response.text}"
                print(f"\033[1;31m[ ZeroNokami ] - {error_message}\033[0m")
                Utilities.log_error(error_message)
                return False
        except requests.RequestException as e:
            error_message = f"Request exception occurred while verifying cookie: {e}"
            print(f"\033[1;31m[ ZeroNokami ] - {error_message}\033[0m")
            Utilities.log_error(error_message)
            return False
        except Exception as e:
            error_message = f"Unexpected exception occurred while verifying cookie: {e}"
            print(f"\033[1;31m[ ZeroNokami ] - {error_message}\033[0m")
            Utilities.log_error(error_message)
            return False
    @staticmethod
    def check_user_online(user_id, cookie=None):
        max_retries = 2
        delay = 2
        body = {"userIds": [user_id]}
        headers = {"Content-Type": "application/json"}
        if cookie is not None:
            headers["Cookie"] = f".ROBLOSECURITY={cookie}"
        for attempt in range(max_retries):
            try:
                with requests.Session() as session:
                    primary_response = session.post("https://presence.roblox.com/v1/presence/users", headers=headers, json=body, timeout=7)
                primary_response.raise_for_status()
                primary_data = primary_response.json()
                primary_presence_type = primary_data["userPresences"][0]["userPresenceType"]
                return primary_presence_type
            except requests.exceptions.RequestException as e:
                print(f"\033[1;31mError checking online status for user {user_id} (Attempt {attempt + 1}) for Roblox API: {e}\033[0m")
                if attempt < max_retries - 1:
                    time.sleep(delay)
                    delay *= 2
        headers = {"Content-Type": "application/json"}
        for attempt in range(max_retries):
            try:
                with requests.Session() as session:
                    primary_response = session.post("https://presence.roproxy.com/v1/presence/users", headers=headers, json=body, timeout=7)
                primary_response.raise_for_status()
                primary_data = primary_response.json()
                primary_presence_type = primary_data["userPresences"][0]["userPresenceType"]
                return primary_presence_type
            except requests.exceptions.RequestException as e:
                print(f"\033[1;31mError checking online status for user {user_id} (Attempt {attempt + 1}) for RoProxy API: {e}\033[0m")
                if attempt < max_retries - 1:
                    time.sleep(delay)
                    delay *= 2
                else:
                    return None
    @staticmethod
    def get_roblox_packages():
        packages = []
        try:
            package_prefix = globals().get("package_prefix", "com.roblox")
            result = subprocess.run(f"pm list packages {package_prefix} | sed 's/package://'", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                for line in result.stdout.strip().splitlines():
                    name = line.strip()
                    packages.append(name)
            else:
                print(f"\033[1;31m[ ZeroNokami ] - Failed to retrieve packages with prefix {package_prefix}.\033[0m")
                Utilities.log_error(f"Failed to retrieve packages with prefix {package_prefix}. Return code: {result.returncode}")
        except Exception as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error retrieving packages: {e}\033[0m")
            Utilities.log_error(f"Error retrieving packages: {e}")
        return packages
    @staticmethod
    def kill_roblox_processes():
        packages = RobloxManager.get_roblox_packages()
        running = SystemMonitor.roblox_processes()
        if not running:
            print("\033[1;32m[ ZeroNokami ] - No Roblox processes to kill.\033[0m")
            return
        for package_name in packages:
            if any(package_name in proc for proc in running):
                os.system(f"nohup /system/bin/am force-stop {package_name} > /dev/null 2>&1 &")
        time.sleep(2)
    @staticmethod
    def kill_roblox_process(package_name):
        print(f"\033[1;96m[ ZeroNokami ] - Killing Roblox process for {package_name}...\033[0m")
        try:
            subprocess.run(
                ["/system/bin/am", "force-stop", package_name],
                capture_output=True,
                text=True,
                check=True
            )
            print(f"\033[1;32m[ ZeroNokami ] - Killed process for {package_name}\033[0m")
            time.sleep(2)
        except subprocess.CalledProcessError as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error killing process for {package_name}: {e}\033[0m")
            Utilities.log_error(f"Error killing process for {package_name}: {e}")
    @staticmethod
    def delete_cache_for_package(package_name):
        cache_path = f'/data/data/{package_name}/cache/'
        if os.path.exists(cache_path):
            os.system(f"rm -rf {cache_path}")
            print(f"\033[1;32m[ ZeroNokami ] - Cache cleared for {package_name}\033[0m")
        else:
            print(f"\033[1;93m[ ZeroNokami ] - No cache found for {package_name}\033[0m")
    @staticmethod
    def launch_roblox(package_name, server_link):
        try:
            RobloxManager.kill_roblox_process(package_name)
            time.sleep(2)
            with status_lock:
                globals()["_uid_"][globals()["_user_"][package_name]] = time.time()
                globals()["package_statuses"][package_name]["Status"] = f"\033[1;36mOpening Roblox for {package_name}...\033[0m"
                UIManager.update_status_table()
            subprocess.run([
                'am', 'start',
                '-a', 'android.intent.action.MAIN',
                '-n', f'{package_name}/com.roblox.client.startup.ActivitySplash'
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            time.sleep(10)
            with status_lock:
                globals()["package_statuses"][package_name]["Status"] = f"\033[1;36mJoining Roblox for {package_name}...\033[0m"
                UIManager.update_status_table()
            subprocess.run([
                'am', 'start',
                '-a', 'android.intent.action.VIEW',
                '-n', f'{package_name}/com.roblox.client.ActivityProtocolLaunch',
                '-d', server_link
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            time.sleep(20)
            with status_lock:
                globals()["package_statuses"][package_name]["Status"] = "\033[1;32mJoined Roblox\033[0m"
                UIManager.update_status_table()
        except Exception as e:
            error_message = f"Error launching Roblox for {package_name}: {e}"
            with status_lock:
                globals()["package_statuses"][package_name]["Status"] = f"\033[1;31m{error_message}\033[0m"
                UIManager.update_status_table()
            print(f"\033[1;31m[ ZeroNokami ] - {error_message}\033[0m")
            Utilities.log_error(error_message)
    @staticmethod
    def inject_cookies_and_appstorage():
        RobloxManager.kill_roblox_processes()
        db_url = "https://raw.githubusercontent.com/nghvit/module/refs/heads/main/import/Cookies"
        appstorage_url = "https://raw.githubusercontent.com/nghvit/module/refs/heads/main/import/appStorage.json"
        downloaded_db_path = FileManager.download_file(db_url, "Cookies.db", binary=True)
        downloaded_appstorage_path = FileManager.download_file(appstorage_url, "appStorage.json", binary=False)
        if not downloaded_db_path or not downloaded_appstorage_path:
            print("\033[1;31m[ ZeroNokami ] - Failed to download necessary files. Exiting.\033[0m")
            Utilities.log_error("Failed to download necessary files for cookie and appStorage injection.")
            return
        packages = RobloxManager.get_roblox_packages()
        if not packages:
            print("\033[1;31m[ ZeroNokami ] - No Roblox packages detected.\033[0m")
            return
        for package_name in packages:
            try:
                cookie = RobloxManager.get_cookie()
                if not cookie:
                    print(f"\033[1;31m[ ZeroNokami ] - Failed to retrieve a cookie for {package_name}. Skipping...\033[0m")
                    break
                user_id = RobloxManager.verify_cookie(cookie)
                if user_id:
                    print(f"\033[1;32m[ ZeroNokami ] - Cookie for {package_name} is valid! User ID: {user_id}\033[0m")
                else:
                    print(f"\033[1;31m[ ZeroNokami ] - Cookie for {package_name} is invalid. Skipping injection...\033[0m")
                    continue
                print(f"\033[1;32m[ ZeroNokami ] - Injecting cookie for {package_name}: {cookie}\033[0m")
                destination_db_dir = f"/data/data/{package_name}/app_webview/Default/"
                destination_appstorage_dir = f"/data/data/{package_name}/files/appData/LocalStorage/"
                os.makedirs(destination_db_dir, exist_ok=True)
                os.makedirs(destination_appstorage_dir, exist_ok=True)
                destination_db_path = os.path.join(destination_db_dir, "Cookies")
                shutil.copyfile(downloaded_db_path, destination_db_path)
                print(f"\033[1;32m[ ZeroNokami ] - Copied Cookies.db to {destination_db_path}\033[0m")
                destination_appstorage_path = os.path.join(destination_appstorage_dir, "appStorage.json")
                shutil.copyfile(downloaded_appstorage_path, destination_appstorage_path)
                print(f"\033[1;32m[ ZeroNokami ] - Copied appStorage.json to {destination_appstorage_path}\033[0m")
                RobloxManager.replace_cookie_value_in_db(destination_db_path, cookie)
            except Exception as e:
                error_message = f"Error injecting cookie for {package_name}: {e}"
                print(f"\033[1;31m[ ZeroNokami ] - {error_message}\033[0m")
                Utilities.log_error(error_message)
        print("\033[1;32m[ ZeroNokami ] - Opening all Roblox tabs...\033[0m")
        failed_packages = []
        for package_name in packages:
            try:
                print(f"\033[1;36m[ ZeroNokami ] - Launching {package_name}...\033[0m")
                cmd_splash = [
                    'am', 'start',
                    '-a', 'android.intent.action.MAIN',
                    '-n', f'{package_name}/com.roblox.client.startup.ActivitySplash'
                ]
                result_splash = subprocess.run(cmd_splash, capture_output=True, text=True)
                if result_splash.returncode != 0:
                    error_message = f"Failed to open Roblox for {package_name}: {result_splash.stderr}"
                    print(f"\033[1;31m[ ZeroNokami ] - {error_message}\033[0m")
                    Utilities.log_error(error_message)
                    failed_packages.append(package_name)
                else:
                    print(f"\033[1;32m[ ZeroNokami ] - Successfully launched {package_name}\033[0m")
            except Exception as e:
                error_message = f"Error launching {package_name}: {e}"
                print(f"\033[1;31m[ ZeroNokami ] - {error_message}\033[0m")
                Utilities.log_error(error_message)
                failed_packages.append(package_name)
        if failed_packages:
            print(f"\033[1;31m[ ZeroNokami ] - Failed to launch packages: {', '.join(failed_packages)}\033[0m")
        else:
            print("\033[1;32m[ ZeroNokami ] - Successfully launched all packages.\033[0m")
        print("\033[1;33m[ ZeroNokami ] - Waiting for all tabs to load (1 minute)...\033[0m")
        time.sleep(60)
        debug_mode = input("\033[1;93m[ ZeroNokami ] - Keep Roblox tabs open for debugging? (y/n): \033[0m").strip().lower()
        if debug_mode != 'y':
            print("\033[1;33m[ ZeroNokami ] - Closing all Roblox tabs after loading...\033[0m")
            RobloxManager.kill_roblox_processes()
            time.sleep(5)
        else:
            print("\033[1;33m[ ZeroNokami ] - Keeping Roblox tabs open for debugging.\033[0m")
        print("\033[1;32m[ ZeroNokami ] - Cookie and appStorage injection, followed by app launch, completed for all packages.\033[0m")
    @staticmethod
    def replace_cookie_value_in_db(db_path, new_cookie_value):
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("UPDATE cookies SET value = ?, last_access_utc = ?, expires_utc = ? WHERE host_key = '.roblox.com' AND name = '.ROBLOSECURITY'", (new_cookie_value, int(time.time() + 11644473600) * 1000000, int(time.time() + 11644473600 + 31536000) * 1000000))
            conn.commit()
            conn.close()
            print("\033[1;32mCookie value replaced successfully in the database!\033[0m")
        except sqlite3.OperationalError as e:
            print(f"\033[1;31mDatabase error during cookie replacement: {e}\033[0m")
        except Exception as e:
            print(f"\033[1;31mError replacing cookie value in database: {e}\033[0m")
    @staticmethod
    def format_server_link(input_link):
        if 'roblox.com' in input_link:
            return input_link
        elif input_link.isdigit():
            return f'roblox://placeID={input_link}'
        else:
            print("\033[1;31m[ ZeroNokami ] - Invalid input! Please enter a valid game ID or private server link.\033[0m")
            return None
class WebhookManager:
    @staticmethod
    def start_webhook_thread():
        global webhook_thread, stop_webhook_thread
        if (webhook_thread is None or not webhook_thread.is_alive()) and not stop_webhook_thread:
            stop_webhook_thread = False
            webhook_thread = threading.Thread(target=WebhookManager.send_webhook)
            webhook_thread.start()
    @staticmethod
    def send_webhook():
        global stop_webhook_thread
        while not stop_webhook_thread:
            try:
                screenshot_path = SystemMonitor.capture_screenshot()
                if not screenshot_path:
                    continue
                info = SystemMonitor.get_system_info()
                if not info:
                    continue
                cpu = f"{info['cpu_usage']:.1f}%"
                mem_used = f"{info['memory_used']:.2f} GB"
                mem_total = f"{info['memory_total']:.2f} GB"
                mem_percent = f"{info['memory_percent']:.1f}%"
                uptime = info['uptime']
                roblox_count = len(info['roblox_packages'])
                roblox_status = f"Running: {roblox_count} instance{'s' if roblox_count != 1 else ''}"
                roblox_details = "\n".join(info['roblox_packages']) if info['roblox_packages'] else "None"
                tool_mem_usage = SystemMonitor.get_memory_usage()
                tool_mem_display = f"{tool_mem_usage} MB" if tool_mem_usage is not None else "Unavailable"
                if roblox_count > 0:
                    status_text = f"🟢 Online"
                else:
                    status_text = "🔴 Offline"
                random_color = random.randint(0, 16777215)
                embed = {
                    "color": random_color,
                    "title": "📈 System Status Monitor",
                    "description": f"Real-time report for **{device_name}**",
                    "fields": [
                        {"name": "🏷️ Device", "value": f"```{device_name}```", "inline": True},
                        {"name": "💾 Total Memory", "value": f"```{mem_total}```", "inline": True},
                        {"name": "⏰ Uptime", "value": f"```{uptime}```", "inline": True},
                        {"name": "⚡ CPU Usage", "value": f"```{cpu}```", "inline": True},
                        {"name": "📊 Memory Usage", "value": f"```{mem_used} ({mem_percent})```", "inline": True},
                        {"name": "🛠️ Tool Memory Usage", "value": f"```{tool_mem_display}```", "inline": True},
                        {"name": "🎮 Total Roblox Processes", "value": f"```{roblox_status}```", "inline": True},
                        {"name": "🔍 Roblox Details", "value": f"```{roblox_details}```", "inline": False},
                        {"name": "✅ Status", "value": f"```{status_text}```", "inline": True}
                    ],
                    "thumbnail": {"url": "https://i.imgur.com/LfeYgCd.png"},
                    "image": {"url": "attachment://screenshot.png"},
                    "footer": {"text": f"Made with 🇻🇳 by ZeroNokami | Hữu Tìnhdz ",
                               "icon_url": "https://i.imgur.com/LfeYgCd.png"},
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                    "author": {"name": "ZeroNokami",
                               "url": "https://discord.gg/chuoihub",
                               "icon_url": "https://i.imgur.com/LfeYgCd.png"}
                }
                with open(screenshot_path, "rb") as file:
                    response = requests.post(
                        webhook_url,
                        data={"payload_json": json.dumps({"embeds": [embed], "username": "ZeroNokami", "avatar_url": "https://i.imgur.com/Bui2u4v.png"})},
                        files={"file": ("screenshot.png", file)}
                    )
                if response.status_code not in (200, 204):
                    print(f"\033[1;31m[ ZeroNokami ] - Error sending device info: {response.status_code}\033[0m")
                    Utilities.log_error(f"Error sending webhook: Status code {response.status_code}")
            except Exception as e:
                print(f"\033[1;31m[ ZeroNokami ] - Webhook error: {e}\033[0m")
                Utilities.log_error(f"Error in webhook thread: {e}")
            time.sleep(webhook_interval * 60)
    @staticmethod
    def stop_webhook():
        global stop_webhook_thread
        stop_webhook_thread = True
    @staticmethod
    def setup_webhook():
        global webhook_url, device_name, webhook_interval, stop_webhook_thread
        try:
            stop_webhook_thread = True
            webhook_url = input("\033[1;35m[ ZeroNokami ] - Enter your Webhook URL: \033[0m")
            device_name = input("\033[1;35m[ ZeroNokami ] - Enter your device name: \033[0m")
            webhook_interval = int(input("\033[1;35m[ ZeroNokami ] - Enter the interval to send Webhook (minutes): \033[0m"))
            FileManager.save_config()
            stop_webhook_thread = False
            threading.Thread(target=WebhookManager.send_webhook).start()
        except Exception as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error during webhook setup: {e}\033[0m")
            Utilities.log_error(f"Error during webhook setup: {e}")
class UIManager:
    @staticmethod
    def print_header(version):
        console = Console(width=120, force_terminal=True)
        
        header = Text(r"""
███████╗███████╗██████╗  ██████╗     ███╗   ███╗ █████╗ ███╗   ██╗ █████╗  ██████╗ ███████╗██████╗ 
   ███╔╝██╔════╝██╔══██╗██╔═══██╗    ████╗ ████║██╔══██╗████╗  ██║██╔══██╗██╔════╝ ██╔════╝██╔══██╗
  ███╔╝ █████╗  ██████╔╝██║   ██║    ██╔████╔██║███████║██╔██╗ ██║███████║██║  ███╗█████╗  ██████╔╝
 ███╔╝  ██╔══╝  ██╔══██╗██║   ██║    ██║╚██╔╝██║██╔══██║██║╚██╗██║██╔══██║██║   ██║██╔══╝  ██╔══██╗
███████╗███████╗██║  ██║╚██████╔╝    ██║ ╚═╝ ██║██║  ██║██║ ╚████║██║  ██║╚██████╔╝███████╗██║  ██║
╚══════╝╚══════╝╚═╝  ╚═╝ ╚═════╝     ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝
        """, style="bold yellow", no_wrap=True)

        config_file = os.path.join("ZeroNokami", "config.json")
        check_executor = "1"
        if os.path.exists(config_file):
            try:
                with open(config_file, "r") as f:
                    config = json.load(f)
                    check_executor = config.get("check_executor", "0")
            except Exception as e:
                console.print(f"[bold red][ ZeroNokami ] - Error reading {config_file}: {e}[/bold red]")
        console.print(header)
        console.print(f"[bold yellow]- Version: [/bold yellow][bold white]{version}[/bold white]")
        console.print(f"[bold yellow]- Credit: [/bold yellow][bold white]ZeroNokami[/bold white]")
        if check_executor == "1":
            console.print("[bold yellow]- Method: [/bold yellow][bold white]Check Executor[/bold white]")
        else:
            console.print("[bold yellow]- Method: [/bold yellow][bold white]Check Online[/bold white]")
        console.print("\n")

    @staticmethod
    def create_dynamic_menu(options):
        console = Console()
        table = Table(
            header_style="bold white",
            border_style="bright_white",
            box=ROUNDED
        )
        table.add_column("No", justify="center", style="bold cyan", width=6)
        table.add_column("Service Name", style="bold magenta", justify="left")
        for i, service in enumerate(options, start=1):
            table.add_row(f"[bold yellow][ {i} ][/bold yellow]", f"[bold blue]{service}[/bold blue]")
        panel = Panel(
            table,
            title="[bold yellow]ZeroNokami - Tool Auto Rejoin[/bold yellow]",
            border_style="yellow",
            box=ROUNDED
        )
        console.print(Align.left(panel))

    @staticmethod
    def create_dynamic_table(headers, rows):
        table = PrettyTable(field_names=headers, border=True, align="l")
        for huy in rows:
            table.add_row(list(huy))
        print(table)

    last_update_time = 0
    update_interval = 5

    @staticmethod
    def update_status_table():
        current_time = time.time()
        if current_time - UIManager.last_update_time < UIManager.update_interval:
            return
       
        cpu_usage = psutil.cpu_percent(interval=2)
        memory_info = psutil.virtual_memory()
        ram = round(memory_info.used / memory_info.total * 100, 2)
        title = f"CPU: {cpu_usage}% | RAM: {ram}%"
        table_packages = PrettyTable(
            field_names=["Package", "Username", "Package Status"],
            title=title,
            border=True,
            align="l"
        )
        for package, info in globals().get("package_statuses", {}).items():
            username = str(info.get("Username", "Unknown"))
            if username != "Unknown":
                obfuscated_username = "******" + username[6:] if len(username) > 6 else "******"
                username = obfuscated_username
            table_packages.add_row([
                str(package),
                username,
                str(info.get("Status", "Unknown"))
            ])
        Utilities.clear_screen()
        UIManager.print_header(version)
        print(table_packages)
class ExecutorManager:
    @staticmethod
    def detect_executors():
        console = Console()
        detected_executors = []
        for executor_name, base_path in executors.items():
            possible_autoexec_paths = [
                os.path.join(base_path, "Autoexec"),
                os.path.join(base_path, "Autoexecute"),
                os.path.join(base_path, "autoexec")
            ]
            for path in possible_autoexec_paths:
                if os.path.exists(path):
                    detected_executors.append(executor_name)
                    console.print(f"[bold green][ ZeroNokami ] - Detected executor: {executor_name}[/bold green]")
                    break
        return detected_executors
   
    @staticmethod
    def write_lua_script(detected_executors):
        console = Console()
        config_file = os.path.join("ZeroNokami", "checkui.lua")
        try:
            with open(config_file, "r") as f:
                lua_script_content = f.read()
        except Exception as e:
            console.print(f"[bold red][ ZeroNokami ] - Error reading config from {config_file}: {e}[/bold red]")
            return
        for executor_name in detected_executors:
            base_path = executors[executor_name]
            possible_autoexec_paths = [
                os.path.join(base_path, "Autoexec"),
                os.path.join(base_path, "Autoexecute"),
                os.path.join(base_path, "autoexec")
            ]
            lua_written = False
            if executor_name.upper() == "KRNL":
                autoruns_path = os.path.join("/storage/emulated/0/krnl/workspace/.storage", "autoruns.json")
                tabs_path = os.path.join("/storage/emulated/0/krnl/workspace/.storage/tabs", "check_executor.luau")
                if os.path.exists(autoruns_path):
                    with open(autoruns_path, "r") as f:
                        try:
                            autoruns_data = json.load(f)
                            if not isinstance(autoruns_data, list):
                                autoruns_data = []
                        except json.JSONDecodeError:
                            autoruns_data = []
                else:
                    autoruns_data = []
                if "check_executor" not in autoruns_data:
                    autoruns_data.append("check_executor")
                    try:
                        with open(autoruns_path, "w") as f:
                            json.dump(autoruns_data, f)
                        console.print(f"[bold green][ ZeroNokami ] - Added script into KRNL autoexec![/bold green]")
                    except Exception as e:
                        console.print(f"[bold red][ ZeroNokami ] - Error updating KRNL autoexec: {e}[/bold red]")
                        Utilities.log_error(f"Error updating KRNL autoexec: {e}")
                else:
                    console.print(f"[bold green][ ZeroNokami ] - Script already exists in KRNL autoexec![/bold green]")
                try:
                    os.makedirs(os.path.dirname(tabs_path), exist_ok=True)
                    with open(tabs_path, "w") as f:
                        f.write(lua_script_content)
                    lua_written = True
                    console.print(f"[bold green][ ZeroNokami ] - Lua script written successfully![/bold green]")
                except Exception as e:
                    console.print(f"[bold red][ ZeroNokami ] - Error writing Lua script to KRNL autoexec: {e}[/bold red]")
                    Utilities.log_error(f"Error writing Lua script to KRNL autoexec: {e}")
            if not lua_written:
                if executor_name.upper() == "DELTA":
                    target_path = os.path.join(base_path, "Autoexecute")
                    os.makedirs(target_path, exist_ok=True)
                    lua_script_path = os.path.join(target_path, "executor_check.lua")
                    try:
                        with open(lua_script_path, 'w') as file:
                            file.write(lua_script_content)
                        lua_written = True
                        console.print(f"[bold green][ ZeroNokami ] - Lua script written to: {lua_script_path}[/bold green]")
                    except Exception as e:
                        console.print(f"[bold red][ ZeroNokami ] - Error writing Lua script to {lua_script_path}: {e}[/bold red]")
                        Utilities.log_error(f"Error writing Lua script to {lua_script_path}: {e}")
                if not lua_written:
                    for path in possible_autoexec_paths:
                        if os.path.exists(path):
                            lua_script_path = os.path.join(path, "executor_check.lua")
                            try:
                                with open(lua_script_path, 'w') as file:
                                    file.write(lua_script_content)
                                lua_written = True
                                console.print(f"[bold green][ ZeroNokami ] - Lua script written to: {lua_script_path}[/bold green]")
                                break
                            except Exception as e:
                                console.print(f"[bold red][ ZeroNokami ] - Error writing Lua script to {lua_script_path}: {e}[/bold red]")
                                Utilities.log_error(f"Error writing Lua script to {lua_script_path}: {e}")
                    if not lua_written:
                        console.print(f"[bold yellow][ ZeroNokami ] - No valid path found to write Lua script for {executor_name}[/bold yellow]")
    @staticmethod
    def check_executor_status(package_name, continuous=True, max_wait_time=180):
        retry_timeout = time.time() + max_wait_time
        while True:
            for workspace in globals()["workspace_paths"]:
                id = globals()["_user_"][package_name]
                file_path = os.path.join(workspace, f"{id}.main")
                if os.path.exists(file_path):
                    return True
            if continuous and time.time() > retry_timeout:
                return False
            time.sleep(20)
    @staticmethod
    def check_executor_and_rejoin(package_name, server_link, next_package_event):
        user_id = globals()["_user_"][package_name]
        detected_executors = ExecutorManager.detect_executors()
        if detected_executors:
            globals()["package_statuses"][package_name]["Status"] = "\033[1;33mChecking executor...\033[0m"
            UIManager.update_status_table()
            while True:
                ExecutorManager.reset_executor_file(package_name)
                try:
                    start_time = time.time()
                    executor_loaded = False
                    while time.time() - start_time < 180:
                        if ExecutorManager.check_executor_status(package_name):
                            globals()["package_statuses"][package_name]["Status"] = "\033[1;32mExecutor has loaded successfully\033[0m"
                            UIManager.update_status_table()
                            executor_loaded = True
                            next_package_event.set()
                            break
                        time.sleep(20)
                    if not executor_loaded:
                        globals()["package_statuses"][package_name]["Status"] = "\033[1;31mExecutor didn't load. Rejoining...\033[0m"
                        UIManager.update_status_table()
                        time.sleep(15)
                        ExecutorManager.reset_executor_file(package_name)
                        time.sleep(0.5)
                        RobloxManager.kill_roblox_process(package_name)
                        RobloxManager.delete_cache_for_package(package_name)
                        time.sleep(15)
                        print(f"\033[1;33m[ ZeroNokami ] - Rejoining {package_name}...\033[0m")
                        globals()["package_statuses"][package_name]["Status"] = "\033[1;36mRejoining\033[0m"
                        UIManager.update_status_table()
                        RobloxManager.launch_roblox(package_name, server_link)
                        globals()["package_statuses"][package_name]["Status"] = "\033[1;32mJoined Roblox\033[0m"
                        UIManager.update_status_table()
                except Exception as e:
                    globals()["package_statuses"][package_name]["Status"] = f"\033[1;31mError checking executor for {package_name}: {e}\033[0m"
                    UIManager.update_status_table()
                    time.sleep(10)
                    ExecutorManager.reset_executor_file(package_name)
                    time.sleep(2)
                    RobloxManager.kill_roblox_process(package_name)
                    RobloxManager.delete_cache_for_package(package_name)
                    time.sleep(10)
                    print(f"\033[1;33m[ ZeroNokami ] - Rejoining {package_name} after error...\033[0m")
                    globals()["package_statuses"][package_name]["Status"] = "\033[1;36mRejoining\033[0m"
                    UIManager.update_status_table()
                    RobloxManager.launch_roblox(package_name, server_link)
                    globals()["package_statuses"][package_name]["Status"] = "\033[1;32mJoined Roblox\033[0m"
                    UIManager.update_status_table()
        else:
            globals()["package_statuses"][package_name]["Status"] = f"\033[1;32mJoined without executor for {user_id}\033[0m"
            UIManager.update_status_table()
            next_package_event.set()
    @staticmethod
    def reset_executor_file(package_name):
        try:
            for workspace in globals()["workspace_paths"]:
                id = globals()["_user_"][package_name]
                file_path = os.path.join(workspace, f"{id}.main")
                if os.path.exists(file_path):
                    os.remove(file_path)
        except:
            pass
    @staticmethod
    def write_custom_script(detected_executors, lua_content):
        console = Console()
        for executor_name in detected_executors:
            base_path = executors[executor_name]
            possible_autoexec_paths = [
                os.path.join(base_path, "Autoexec"),
                os.path.join(base_path, "Autoexecute"),
                os.path.join(base_path, "autoexec")
            ]
            lua_written = False
            if executor_name.upper() == "KRNL":
                autoruns_path = os.path.join("/storage/emulated/0/krnl/workspace/.storage", "autoruns.json")
                tabs_path = os.path.join("/storage/emulated/0/krnl/workspace/.storage/tabs", "auto_execute.luau")
                if os.path.exists(autoruns_path):
                    with open(autoruns_path, "r") as f:
                        try:
                            autoruns_data = json.load(f)
                            if not isinstance(autoruns_data, list):
                                autoruns_data = []
                        except json.JSONDecodeError:
                            autoruns_data = []
                else:
                    autoruns_data = []
                if "auto_execute" not in autoruns_data:
                    autoruns_data.append("auto_execute")
                    try:
                        with open(autoruns_path, "w") as f:
                            json.dump(autoruns_data, f)
                        console.print(f"[bold green][ ZeroNokami ] - Added custom script into KRNL autoexec![/bold green]")
                    except Exception as e:
                        console.print(f"[bold red][ ZeroNokami ] - Error updating KRNL autoexec for custom script: {e}[/bold red]")
                        Utilities.log_error(f"Error updating KRNL autoexec for custom script: {e}")
                else:
                    console.print(f"[bold green][ ZeroNokami ] - Custom script already exists in KRNL autoexec![/bold green]")
                try:
                    os.makedirs(os.path.dirname(tabs_path), exist_ok=True)
                    with open(tabs_path, "w") as f:
                        f.write(lua_content)
                    lua_written = True
                    console.print(f"[bold green][ ZeroNokami ] - Custom Lua script written successfully to KRNL![/bold green]")
                except Exception as e:
                    console.print(f"[bold red][ ZeroNokami ] - Error writing custom Lua script to KRNL autoexec: {e}[/bold red]")
                    Utilities.log_error(f"Error writing custom Lua script to KRNL autoexec: {e}")
            if not lua_written:
                if executor_name.upper() == "DELTA":
                    target_path = os.path.join(base_path, "Autoexecute")
                    os.makedirs(target_path, exist_ok=True)
                    lua_script_path = os.path.join(target_path, "auto_execute.lua")
                    try:
                        with open(lua_script_path, 'w') as file:
                            file.write(lua_content)
                        lua_written = True
                        console.print(f"[bold green][ ZeroNokami ] - Custom Lua script written to: {lua_script_path}[/bold green]")
                    except Exception as e:
                        console.print(f"[bold red][ ZeroNokami ] - Error writing custom Lua script to {lua_script_path}: {e}[/bold red]")
                        Utilities.log_error(f"Error writing custom Lua script to {lua_script_path}: {e}")
                if not lua_written:
                    for path in possible_autoexec_paths:
                        if os.path.exists(path):
                            lua_script_path = os.path.join(path, "auto_execute.lua")
                            try:
                                with open(lua_script_path, 'w') as file:
                                    file.write(lua_content)
                                lua_written = True
                                console.print(f"[bold green][ ZeroNokami ] - Custom Lua script written to: {lua_script_path}[/bold green]")
                                break
                            except Exception as e:
                                console.print(f"[bold red][ ZeroNokami ] - Error writing custom Lua script to {lua_script_path}: {e}[/bold red]")
                                Utilities.log_error(f"Error writing custom Lua script to {lua_script_path}: {e}")
                    if not lua_written:
                        console.print(f"[bold yellow][ ZeroNokami ] - No valid path found to write custom Lua script for {executor_name}[/bold yellow]")
class Runner:
    @staticmethod
    def launch_package_sequentially(server_links):
        next_package_event = Event()
        next_package_event.set()
        packages_to_launch = []
        for package_name, server_link in server_links:
            user_id = globals()["_user_"].get(package_name, "Unknown")
            if user_id == "Unknown":
                print(f"\033[1;31m[ ZeroNokami ] - No UserID found for {package_name}, skipping...\033[0m")
                continue
            username = FileManager.get_username(user_id)
            with status_lock:
                globals()["package_statuses"][package_name] = {
                    "Username": username,
                    "Status": "\033[1;33mWaiting to Join\033[0m"
                }
            packages_to_launch.append((package_name, server_link))
        total_packages = len(packages_to_launch)
        for index, (package_name, server_link) in enumerate(packages_to_launch):
            next_package_event.clear()
            print(f"\033[1;32m[ ZeroNokami ] - Launching package {index + 1}/{total_packages}: {package_name}\033[0m")
            try:
                RobloxManager.launch_roblox(package_name, server_link)
                if globals()["check_exec_enable"] == "1":
                    detected_executors = ExecutorManager.detect_executors()
                    if len(detected_executors) > 0:
                        ExecutorManager.write_lua_script(detected_executors)
                    else:
                        print(f"\033[1;33m[ ZeroNokami ] - No executors detected for {package_name}\033[0m")
            except Exception as e:
                Utilities.log_error(f"Error launching Roblox for {package_name}: {e}\n{traceback.format_exc()}")
                print(f"\033[1;31mError launching Roblox for {package_name}: {e}\033[0m")
                globals()["package_statuses"][package_name]["Status"] = "\033[1;31mLaunch failed\033[0m"
                UIManager.update_status_table()
            if globals()["check_exec_enable"] == "1":
                threading.Thread(
                    target=ExecutorManager.check_executor_and_rejoin,
                    args=(package_name, server_link, next_package_event),
                    daemon=True
                ).start()
            else:
                next_package_event.set()
            next_package_event.wait()
    @staticmethod
    def monitor_presence(server_links, stop_event):
        in_game_status = {package_name: False for package_name, _ in server_links}
       
        while not stop_event.is_set():
            try:
                if globals()["check_exec_enable"] == "0":
                    for package_name, server_link in server_links:
                        ckhuy = FileManager.xuat(f"/data/data/{package_name}/app_webview/Default/Cookies")
                        user_id = globals()["_user_"][package_name]
                       
                        presence_type = RobloxManager.check_user_online(user_id, ckhuy)
                       
                        if not in_game_status[package_name]:
                            if presence_type == 2:
                                with status_lock:
                                    globals()["package_statuses"][package_name]["Status"] = "\033[1;32mIn-Game\033[0m"
                                    UIManager.update_status_table()
                                in_game_status[package_name] = True
                                print(f"\033[1;32m[ ZeroNokami ] - {user_id} is now In-Game, monitoring started.\033[0m")
                            continue
                       
                        if presence_type != 2:
                            with status_lock:
                                globals()["package_statuses"][package_name]["Status"] = "\033[1;31mNot In-Game, Rejoining!\033[0m"
                                UIManager.update_status_table()
                            print(f"\033[1;31m[ ZeroNokami ] - {user_id} confirmed offline, rejoining...\033[0m")
                            RobloxManager.kill_roblox_process(package_name)
                            RobloxManager.delete_cache_for_package(package_name)
                            time.sleep(2)
                            threading.Thread(target=RobloxManager.launch_roblox, args=[package_name, server_link], daemon=True).start()
                        else:
                            with status_lock:
                                globals()["package_statuses"][package_name]["Status"] = "\033[1;32mIn-Game\033[0m"
                                UIManager.update_status_table()
                time.sleep(60)
            except Exception as e:
                Utilities.log_error(f"Error in presence monitor: {e}")
                time.sleep(60)
    @staticmethod
    def force_rejoin(server_links, interval, stop_event):
        start_time = time.time()
        force_rejoin_interval = float(interval) if interval and isinstance(interval, (int, float)) else float('inf')
        while not stop_event.is_set():
            if force_rejoin_interval != float('inf') and (time.time() - start_time >= force_rejoin_interval):
                print("\033[1;31m[ ZeroNokami ] - Force killing Roblox processes due to time limit.\033[0m")
                RobloxManager.kill_roblox_processes()
                start_time = time.time()
                print("\033[1;33m[ ZeroNokami ] - Waiting for 5 seconds before starting the rejoin process...\033[0m")
                time.sleep(5)
                Runner.launch_package_sequentially(server_links)
            time.sleep(120)
    @staticmethod
    def update_status_table_periodically():
        while True:
            UIManager.update_status_table()
            time.sleep(30)
def check_activation_status():
    try:
        response = requests.get("https://raw.githubusercontent.com/nghvit/module/refs/heads/main/status/customize", timeout=5)
        response.raise_for_status()
        content = response.text.strip()
        if content == "true":
            print("\033[1;32m[ ZeroNokami ] - Activation status: Enabled. Proceeding with tool execution.\033[0m")
            return True
        elif content == "false":
            print("\033[1;31m[ ZeroNokami ] - Activation status: Disabled. Tool execution halted.\033[0m")
            return False
        else:
            print(f"\033[1;31m[ ZeroNokami ] - Invalid activation status received: {content}. Halting execution.\033[0m")
            Utilities.log_error(f"Invalid activation status: {content}")
            return False
    except requests.RequestException as e:
        print(f"\033[1;31m[ ZeroNokami ] - Error checking activation status: {e}\033[0m")
        Utilities.log_error(f"Error checking activation status: {e}")
        return False
def set_android_id(android_id):
    try:
        subprocess.run(["settings", "put", "secure", "android_id", android_id], check=True)
    except Exception as e:
        Utilities.log_error(f"Failed to set Android ID: {e}")
def auto_change_android_id():
    global auto_android_id_enabled, auto_android_id_value
    while auto_android_id_enabled:
        if auto_android_id_value:
            set_android_id(auto_android_id_value)
        time.sleep(2)
def auto_execute_setup():
    try:
        accounts = FileManager.load_accounts()
        if not accounts:
            print("\033[1;31m[ ZeroNokami ] - No accounts found. Please set up User IDs first.\033[0m")
            return
        usernames = []
        user_id_to_username = {}
        for _, user_id in accounts:
            username = FileManager.get_username(user_id)
            if username != "Unknown":
                usernames.append(username)
                user_id_to_username[user_id] = username
        
        # DEBUG: In ra để kiểm tra
        print("\033[1;36m[ DEBUG ] - User ID to Username mapping:\033[0m")
        for uid, uname in user_id_to_username.items():
            print(f"\033[1;36m  User ID: {uid} -> Username: {uname}\033[0m")
        
        if not usernames:
            print("\033[1;31m[ ZeroNokami ] - No valid usernames found.\033[0m")
            return
        username_file = "Username.json"
        with open(username_file, "w") as f:
            json.dump({"usernames": usernames}, f)
        print(f"\033[1;32m[ ZeroNokami ] - Usernames saved to {username_file}\033[0m")
        print("\033[1;32m[ ZeroNokami] - Script Saver\033[0m")
        same_script_choice = input("\033[1;93m[ ZeroNokami] - All Accounts Running The Same Script (y/n): \033[0m").strip().lower()
        detected_executors = ExecutorManager.detect_executors()
        if not detected_executors:
            print("\033[1;31m[ ZeroNokami ] - No executors detected. Cannot set up auto execute.\033[0m")
            return
        if same_script_choice == "y":
            print("\033[1;93m[ ZeroNokami ] - Enter The Script (press Enter when done): \033[0m")
            lines = []
            while True:
                line = input()
                if line == "":
                    break
                lines.append(line)
            script = "\n".join(lines).strip()
            
            if not script:
                print("\033[1;31m[ ZeroNokami ] - Script cannot be empty.\033[0m")
                return
            
            script_escaped = script.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n")
            lua_content = f'loadstring("{script_escaped}")()'
            ExecutorManager.write_custom_script(detected_executors, lua_content)
            print("\033[1;32m[ ZeroNokami] - Script Saved\033[0m")
        else:
            scripts = {}
            
            for user_id, username in user_id_to_username.items():
                # DEBUG: In ra user_id và username hiện tại
                print(f"\033[1;36m[ DEBUG ] - Processing User ID: {user_id}, Username: {username}\033[0m")
                
                print(f"\033[1;93m[ ZeroNokami ] - Enter The Script For The Account {username} (press Enter twice when done): \033[0m")
                lines = []
                empty_count = 0
                while True:
                    line = input()
                    if line == "":
                        empty_count += 1
                        if empty_count >= 2:
                            break
                    else:
                        empty_count = 0
                        lines.append(line)
                
                script = "\n".join(lines).strip()
                
                if script:
                    scripts[user_id] = script
                    print(f"\033[1;32m[ ZeroNokami] - Script Saved For {username}\033[0m")
                else:
                    print(f"\033[1;33m[ ZeroNokami] - No script entered for {username}, skipping.\033[0m")
            
            if not scripts:
                print("\033[1;31m[ ZeroNokami ] - No scripts entered.\033[0m")
                return
            
            lua_content = 'local userid = game.Players.LocalPlayer.UserId\n'
            for user_id, script in scripts.items():
                script_escaped = script.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n")
                lua_content += f'if userid == {user_id} then\n    loadstring("{script_escaped}")()\nend\n'
            
            ExecutorManager.write_custom_script(detected_executors, lua_content)
            print("\033[1;32m[ ZeroNokami] - All Scripts Saved Successfully\033[0m")
    except Exception as e:
        print(f"\033[1;31m[ ZeroNokami ] - Error in auto execute setup: {e}\033[0m")
        Utilities.log_error(f"Auto execute setup error: {e}")

def main():
    global stop_webhook_thread, webhook_interval
    global auto_android_id_enabled, auto_android_id_thread, auto_android_id_value
    if not check_activation_status():
        print("\033[1;31m[ ZeroNokami ] - Exiting due to activation status check failure.\033[0m")
        return
   
    FileManager._load_config()
   
    if not globals().get("command_8_configured", False):
        globals()["check_exec_enable"] = "1"
        globals()["lua_script_template"] = 'task.spawn(function()local a=tostring(game.Players.LocalPlayer.UserId)..".main"while true do pcall(function()if isfile(a)then delfile(a)end; local success,err=pcall(function()writefile(a,"https://discord.gg/FcEGmkNDDe")end)while not success do task.wait(1); success,err=pcall(function()writefile(a,"https://discord.gg/FcEGmkNDDe")end)end end) task.wait(10) end end)'
        config_file = os.path.join("ZeroNokami", "checkui.lua")
        try:
            os.makedirs("ZeroNokami", exist_ok=True)
            with open(config_file, "w") as f:
                f.write(globals()["lua_script_template"])
            print("\033[1;32m[ ZeroNokami ] - Default script saved to checkui.lua\033[0m")
        except Exception as e:
            print(f"\033[1;31m[ ZeroNokami ] - Error saving default script to {config_file}: {e}\033[0m")
            Utilities.log_error(f"Error saving default script to {config_file}: {e}")
        FileManager.save_config()
    if webhook_interval is None:
        print("\033[1;31m[ ZeroNokami ] - Webhook interval not set, disabled.\033[0m")
        webhook_interval = float('inf')
    if webhook_url and device_name and webhook_interval != float('inf'):
        WebhookManager.start_webhook_thread()
    else:
        print("\033[1;33m[ ZeroNokami ] - Webhook not configured or disabled.\033[0m")
    stop_main_event = threading.Event()
    while True:
        Utilities.clear_screen()
        UIManager.print_header(version)
        FileManager.check_and_create_cookie_file()
        menu_options = [
            "Start Auto Rejoin (Auto setup User ID)",
            "Setup Game ID for Packages",
            "Auto Login with Cookie",
            "Enable Discord Webhook",
            "Auto Check User Setup",
            "Configure Package Prefix",
            "Auto Change Android ID",
            "Auto Execute Script Setup"
        ]
        UIManager.create_dynamic_menu(menu_options)
        setup_type = input("\033[1;93m[ ZeroNokami ] - Enter command: \033[0m")
       
        if setup_type == "1":
            try:
                FileManager.setup_user_ids()
               
                globals()["accounts"] = FileManager.load_accounts()
               
                if not globals()["accounts"]:
                    print("\033[1;31m[ ZeroNokami ] - Setup ran, but no User IDs were found. Cannot start Auto Rejoin.\033[0m")
                    input("\033[1;32mPress Enter to return...\033[0m")
                    continue
               
                server_links = FileManager.load_server_links()
                globals()["_uid_"] = {}
                if not server_links:
                    print("\033[1;31m[ ZeroNokami ] - No game ID or server link set up. Please run option 2 first.\033[0m")
                    input("\033[1;32mPress Enter to return...\033[0m")
                    continue
                force_rejoin_input = input("\033[1;93m[ ZeroNokami ] - Force rejoin interval (minutes, 'q' to skip): \033[0m")
                force_rejoin_interval = float('inf') if force_rejoin_input.lower() == 'q' else int(force_rejoin_input) * 60
                if force_rejoin_interval <= 0:
                    print("\033[1;31m[ ZeroNokami ] - Interval must be positive.\033[0m")
                    input("\033[1;32mPress Enter to return...\033[0m")
                    continue
                RobloxManager.kill_roblox_processes()
                time.sleep(5)
                Runner.launch_package_sequentially(server_links)
                globals()["is_runner_ez"] = True
                for task in [
                    (Runner.monitor_presence, (server_links, stop_main_event)),
                    (Runner.force_rejoin, (server_links, force_rejoin_interval, stop_main_event)),
                    (Runner.update_status_table_periodically, ())
                ]:
                    threading.Thread(target=task[0], args=task[1], daemon=True).start()
                while not stop_main_event.is_set():
                    time.sleep(500)
                    with status_lock:
                        UIManager.update_status_table()
                    Utilities.collect_garbage()
            except Exception as e:
                print(f"\033[1;31m[ ZeroNokami ] - Error: {e}\033[0m")
                Utilities.log_error(f"Setup error: {e}")
                input("\033[1;32mPress Enter to return...\033[0m")
                continue
        if setup_type == "2":
            try:
                print("\033[1;32m[ ZeroNokami ] - Auto Setup User IDs from appStorage.json...\033[0m")
                packages = RobloxManager.get_roblox_packages()
                accounts = []
                for package_name in packages:
                    file_path = f'/data/data/{package_name}/files/appData/LocalStorage/appStorage.json'
                    try:
                        user_id = FileManager.find_userid_from_file(file_path)
                        if user_id and user_id != "-1":
                            accounts.append((package_name, user_id))
                            print(f"\033[96m[ ZeroNokami ] - Found UserId for {package_name}: {user_id}\033[0m")
                        else:
                            print(f"\033[1;31m[ ZeroNokami ] - UserId not found for {package_name}.\033[0m")
                    except Exception as e:
                        print(f"\033[1;31m[ ZeroNokami ] - Error reading file for {package_name}: {e}\033[0m")
                        Utilities.log_error(f"Error reading appStorage.json for {package_name}: {e}")
                if accounts:
                    FileManager.save_accounts(accounts)
                    print("\033[1;32m[ ZeroNokami ] - User IDs saved!\033[0m")
                else:
                    print("\033[1;31m[ ZeroNokami ] - No User IDs found.\033[0m")
                    input("\033[1;32mPress Enter to return...\033[0m")
                    continue
                print("\033[93m[ ZeroNokami ] - Select game:\033[0m")
                games = [
                    "1. Blox Fruits", "2. Grow A Garden", "3. King Legacy", "4. Fisch",
                    "5. Bee Swarm Simulator", "6. Anime Last Stand", "7. Dead Rails Alpha",
                    "8. All Star Tower Defense X", "9. 99 Nights In The Forest", "10. Murder Mystery 2",
                    "11. Steal A Brainrot", "12. Blue Lock Rivals", "13. Arise Crossover", "14. Escape Tsunami For Brainrots", "15. Other game or Private Server Link"
                ]
                for game in games:
                    print(f"\033[96m{game}\033[0m")
                choice = input("\033[93m[ ZeroNokami ] - Enter choice: \033[0m").strip()
                game_ids = {
                    "1": "2753915549", "2": "126884695634066", "3": "4520749081", "4": "16732694052",
                    "5": "1537690962", "6": "12886143095", "7": "116495829188952", "8": "17687504411",
                    "9": "79546208627805", "10": "142823291", "11": "109983668079237", "12": "18668065416",
                    "13": "87039211657390", "14": "131623223084840"
                }
                if choice in game_ids:
                    server_link = game_ids[choice]
                elif choice == "15":
                    server_link = input("\033[93m[ ZeroNokami ] - Enter game ID or private server link: \033[0m")
                else:
                    print("\033[1;31m[ ZeroNokami ] - Invalid choice.\033[0m")
                    input("\033[1;32mPress Enter to return...\033[0m")
                    continue
                formatted_link = RobloxManager.format_server_link(server_link)
                if formatted_link:
                    server_links = [(package_name, formatted_link) for package_name, _ in accounts]
                    FileManager.save_server_links(server_links)
                else:
                    print("\033[1;31m[ ZeroNokami ] - Invalid server link.\033[0m")
            except Exception as e:
                print(f"\033[1;31m[ ZeroNokami ] - Error: {e}\033[0m")
                Utilities.log_error(f"Setup error: {e}")
           
            input("\033[1;32mPress Enter to return...\033[0m")
            continue
        elif setup_type == "3":
            RobloxManager.inject_cookies_and_appstorage()
            input("\033[1;32m\nPress Enter to exit...\033[0m")
            continue
        elif setup_type == "4":
            WebhookManager.setup_webhook()
            input("\033[1;32m\nPress Enter to exit...\033[0m")
            continue
        elif setup_type == "5":
            try:
                print("\033[1;35m[1]\033[1;32m Executor Check\033[0m \033[1;35m[2]\033[1;36m Online Check\033[0m")
                config_choice = input("\033[1;93m[ ZeroNokami ] - Select check method (1-2, 'q' to keep default): \033[0m").strip()
                if config_choice.lower() == "q":
                    globals()["check_exec_enable"] = "1"
                    globals()["lua_script_template"] = 'task.spawn(function()local a=tostring(game.Players.LocalPlayer.UserId)..".main"while true do pcall(function()if isfile(a)then delfile(a)end; local success,err=pcall(function()writefile(a,"https://discord.gg/FcEGmkNDDe")end)while not success do task.wait(1); success,err=pcall(function()writefile(a,"https://discord.gg/FcEGmkNDDe")end)end end) task.wait(10) end end)'
                    print("\033[1;32m[ ZeroNokami ] - Default set: Executor + ZeroNokami Check\033[0m")
                elif config_choice == "1":
                    globals()["check_exec_enable"] = "1"
                    globals()["lua_script_template"] = 'task.spawn(function()local a=tostring(game.Players.LocalPlayer.UserId)..".main"while true do pcall(function()if isfile(a)then delfile(a)end; local success,err=pcall(function()writefile(a,"https://discord.gg/FcEGmkNDDe")end)while not success do task.wait(1); success,err=pcall(function()writefile(a,"https://discord.gg/FcEGmkNDDe")end)end end) task.wait(10) end end)'
                    print("\033[1;32m[ ZeroNokami ] - Set to Executor + ZeroNokami Check\033[0m")
                elif config_choice == "2":
                    globals()["check_exec_enable"] = "0"
                    globals()["lua_script_template"] = None
                    print("\033[1;36m[ ZeroNokami ] - Set to Online Check.\033[0m")
                else:
                    print("\033[1;31m[ ZeroNokami ] - Invalid choice. Keeping default.\033[0m")
                    globals()["check_exec_enable"] = "1"
                    globals()["lua_script_template"] = 'task.spawn(function()local a=tostring(game.Players.LocalPlayer.UserId)..".main"while true do pcall(function()if isfile(a)then delfile(a)end; local success,err=pcall(function()writefile(a,"https://discord.gg/FcEGmkNDDe")end)while not success do task.wait(1); success,err=pcall(function()writefile(a,"https://discord.gg/FcEGmkNDDe")end)end end) task.wait(10) end end)'
                config_file = os.path.join("ZeroNokami", "checkui.lua")
                if globals()["lua_script_template"]:
                    try:
                        os.makedirs("ZeroNokami", exist_ok=True)
                        with open(config_file, "w") as f:
                            f.write(globals()["lua_script_template"])
                        print(f"\033[1;36m[ ZeroNokami ] - Script saved to {config_file}\033[0m")
                    except Exception as e:
                        print(f"\033[1;31m[ ZeroNokami ] - Error saving script: {e}\033[0m")
                        Utilities.log_error(f"Error saving script to {config_file}: {e}")
                else:
                    if os.path.exists(config_file):
                        try:
                            os.remove(config_file)
                            print(f"\033[1;36m[ ZeroNokami ] - Removed {config_file} for Online Check.\033[0m")
                        except Exception as e:
                            print(f"\033[1;31m[ ZeroNokami ] - Error removing {config_file}: {e}\033[0m")
                            Utilities.log_error(f"Error removing {config_file}: {e}")
                globals()["command_8_configured"] = True
                FileManager.save_config()
                print("\033[1;32m[ ZeroNokami ] - Check method configuration saved.\033[0m")
            except Exception as e:
                print(f"\033[1;31m[ ZeroNokami ] - Error setting up check method: {e}\033[0m")
                Utilities.log_error(f"Check method setup error: {e}")
                input("\033[1;32mPress Enter to return...\033[0m")
                continue
            input("\033[1;32mPress Enter to return...\033[0m")
            continue
        elif setup_type == "6":
            try:
                current_prefix = globals().get("package_prefix", "com.roblox")
                print(f"\033[1;32m[ ZeroNokami ] - Current package prefix: {current_prefix}\033[0m")
                new_prefix = input("\033[1;93m[ ZeroNokami ] - Enter new package prefix (or press Enter to keep current): \033[0m").strip()
               
                if new_prefix:
                    globals()["package_prefix"] = new_prefix
                    FileManager.save_config()
                    print(f"\033[1;32m[ ZeroNokami ] - Package prefix updated to: {new_prefix}\033[0m")
                else:
                    print(f"\033[1;33m[ ZeroNokami ] - Package prefix unchanged: {current_prefix}\033[0m")
            except Exception as e:
                print(f"\033[1;31m[ ZeroNokami ] - Error setting package prefix: {e}\033[0m")
                Utilities.log_error(f"Error setting package prefix: {e}")
                input("\033[1;32mPress Enter to return...\033[0m")
                continue
            input("\033[1;32mPress Enter to return...\033[0m")
            continue
        elif setup_type == "7":
            global auto_android_id_enabled, auto_android_id_thread, auto_android_id_value
            if not auto_android_id_enabled:
                android_id = input("\033[1;93m[ ZeroNokami ] - Enter Android ID to spam set: \033[0m").strip()
                if not android_id:
                    print("\033[1;31m[ ZeroNokami ] - Android ID cannot be empty.\033[0m")
                    input("\033[1;32mPress Enter to return...\033[0m")
                    continue
                auto_android_id_value = android_id
                auto_android_id_enabled = True
                if auto_android_id_thread is None or not auto_android_id_thread.is_alive():
                    auto_android_id_thread = threading.Thread(target=auto_change_android_id, daemon=True)
                    auto_android_id_thread.start()
                print("\033[1;32m[ ZeroNokami ] - Auto change Android ID enabled.\033[0m")
            else:
                auto_android_id_enabled = False
                print("\033[1;31m[ ZeroNokami ] - Auto change Android ID disabled.\033[0m")
            input("\033[1;32mPress Enter to return...\033[0m")
            continue
        elif setup_type == "8":
            auto_execute_setup()
            input("\033[1;32mPress Enter to return...\033[0m")
            continue
if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"\033[1;31m[ ZeroNokami ] - Error during initialization: {e}\033[0m")
        Utilities.log_error(f"Initialization error: {e}")
        raise
